"use strict";(self.webpackChunkfluss_website=self.webpackChunkfluss_website||[]).push([[6800],{6242:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"table-design/overview","title":"Table Overview","description":"Database","source":"@site/versioned_docs/version-0.5/table-design/overview.md","sourceDirName":"table-design","slug":"/table-design/overview","permalink":"/docs/0.5/table-design/overview","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/fluss/edit/main/website/docs/table-design/overview.md","tags":[],"version":"0.5","sidebarPosition":2,"frontMatter":{"sidebar_label":"Overview","sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Deploying with Docker","permalink":"/docs/0.5/install-deploy/deploying-with-docker"},"next":{"title":"Log Table","permalink":"/docs/0.5/table-design/table-types/log-table"}}');var i=n(4848),s=n(8453);const o={sidebar_label:"Overview",sidebar_position:2},l="Table Overview",r={},d=[{value:"Database",id:"database",level:2},{value:"Table",id:"table",level:2},{value:"Table Data Organization",id:"table-data-organization",level:2},{value:"Partition",id:"partition",level:3},{value:"Bucket",id:"bucket",level:3},{value:"LogTablet",id:"logtablet",level:3},{value:"KvTablet",id:"kvtablet",level:3}];function c(e){const a={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(a.header,{children:(0,i.jsx)(a.h1,{id:"table-overview",children:"Table Overview"})}),"\n",(0,i.jsx)(a.h2,{id:"database",children:"Database"}),"\n",(0,i.jsx)(a.p,{children:"A Database is a collection of Table objects. You can create/delete databases or create/modify/delete tables under a database."}),"\n",(0,i.jsx)(a.h2,{id:"table",children:"Table"}),"\n",(0,i.jsx)(a.p,{children:"In Fluss, a Table is the fundamental unit of user data storage, organized into rows and columns. Tables are stored within specific databases, adhering to a hierarchical structure (database -> table)."}),"\n",(0,i.jsx)(a.p,{children:"Tables are classified into two types based on the presence of a primary key:"}),"\n",(0,i.jsxs)(a.ul,{children:["\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.strong,{children:"Log Tables:"}),"\n",(0,i.jsxs)(a.ul,{children:["\n",(0,i.jsx)(a.li,{children:"Designed for append-only scenarios."}),"\n",(0,i.jsx)(a.li,{children:"Support only INSERT operations."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.strong,{children:"PrimaryKey Tables:"}),"\n",(0,i.jsxs)(a.ul,{children:["\n",(0,i.jsx)(a.li,{children:"Used for updating and managing data in business databases."}),"\n",(0,i.jsx)(a.li,{children:"Support INSERT, UPDATE, and DELETE operations based on the defined primary key."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(a.p,{children:["A Table becomes a ",(0,i.jsx)(a.a,{href:"/docs/0.5/table-design/data-distribution/partitioning",children:"Partitioned Table"})," when a partition column is defined. Data with the same partition value is stored in the same partition. Partition columns can be applied to both Log Tables and PrimaryKey Tables, but with specific considerations:"]}),"\n",(0,i.jsxs)(a.ul,{children:["\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.strong,{children:"For Log Tables"}),", partitioning is commonly used for log data, typically based on date columns, to facilitate data separation and cleaning."]}),"\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.strong,{children:"For PrimaryKey Tables"}),", the partition column must be a subset of the primary key to ensure uniqueness."]}),"\n"]}),"\n",(0,i.jsx)(a.p,{children:"This design ensures efficient data organization, flexibility in handling different use cases, and adherence to data integrity constraints."}),"\n",(0,i.jsx)(a.h2,{id:"table-data-organization",children:"Table Data Organization"}),"\n",(0,i.jsx)(a.p,{children:(0,i.jsx)(a.img,{alt:"Table Data Organization",src:n(3519).A+"",width:"2104",height:"1381"})}),"\n",(0,i.jsx)(a.h3,{id:"partition",children:"Partition"}),"\n",(0,i.jsxs)(a.p,{children:["A ",(0,i.jsx)(a.strong,{children:"partition"})," is a logical division of a table's data into smaller, more manageable subsets based on the values of one or more specified columns, known as partition columns.\nEach unique value (or combination of values) in the partition column(s) defines a distinct partition."]}),"\n",(0,i.jsx)(a.h3,{id:"bucket",children:"Bucket"}),"\n",(0,i.jsxs)(a.p,{children:["A ",(0,i.jsx)(a.strong,{children:"bucket"})," horizontally divides the data of a table/partition into ",(0,i.jsx)(a.code,{children:"N"})," buckets according to the bucketing policy.\nThe number of buckets ",(0,i.jsx)(a.code,{children:"N"})," can be configured per table. A bucket is the smallest unit of data migration and backup.\nThe data of a bucket consists of a LogTablet and a (optional) KvTablet."]}),"\n",(0,i.jsx)(a.h3,{id:"logtablet",children:"LogTablet"}),"\n",(0,i.jsxs)(a.p,{children:["A ",(0,i.jsx)(a.strong,{children:"LogTablet"})," needs to be generated for each bucket of Log and PrimaryKey tables.\nFor Log Tables, the LogTablet is both the primary table data and the log data. For PrimaryKey tables, the LogTablet acts\nas the log data for the primary table data."]}),"\n",(0,i.jsxs)(a.ul,{children:["\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.strong,{children:"Segment:"})," The smallest unit of log storage in the ",(0,i.jsx)(a.strong,{children:"LogTablet"}),". A segment consists of an ",(0,i.jsx)(a.strong,{children:".index"})," file and a ",(0,i.jsx)(a.strong,{children:".log"})," data file."]}),"\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.strong,{children:".index:"})," An ",(0,i.jsx)(a.code,{children:"offset sparse index"})," that stores the mappings between the physical byte address in the message relative offset -> .log file."]}),"\n",(0,i.jsxs)(a.li,{children:[(0,i.jsx)(a.strong,{children:".log:"})," Compact arrangement of log data."]}),"\n"]}),"\n",(0,i.jsx)(a.h3,{id:"kvtablet",children:"KvTablet"}),"\n",(0,i.jsx)(a.p,{children:"Each bucket of the PrimaryKey table needs to generate a KvTablet. Underlying, each KvTablet corresponds to an embedded RocksDB instance. RocksDB is an LSM (log structured merge) engine which helps KvTablet supports high-performance updates and lookup query."})]})}function h(e={}){const{wrapper:a}={...(0,s.R)(),...e.components};return a?(0,i.jsx)(a,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},3519:(e,a,n)=>{n.d(a,{A:()=>t});const t=n.p+"assets/images/data_organization-c63fd910ab4f86359e60234f855bbb74.png"},8453:(e,a,n)=>{n.d(a,{R:()=>o,x:()=>l});var t=n(6540);const i={},s=t.createContext(i);function o(e){const a=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function l(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(s.Provider,{value:a},e.children)}}}]);