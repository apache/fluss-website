"use strict";(self.webpackChunkfluss_website=self.webpackChunkfluss_website||[]).push([[1476],{8453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>r});var i=t(6540);const s={},a=i.createContext(s);function l(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(a.Provider,{value:n},e.children)}},9951:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"table-design/table-types/pk-table/index","title":"PrimaryKey Table","description":"\x3c!--","source":"@site/docs/table-design/table-types/pk-table/index.md","sourceDirName":"table-design/table-types/pk-table","slug":"/table-design/table-types/pk-table/","permalink":"/docs/next/table-design/table-types/pk-table/","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/fluss/edit/main/website/docs/table-design/table-types/pk-table/index.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"PrimaryKey Table","sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"Log Table","permalink":"/docs/next/table-design/table-types/log-table"},"next":{"title":"Merge Engines","permalink":"/docs/next/table-design/table-types/pk-table/merge-engines/"}}');var s=t(4848),a=t(8453);const l={title:"PrimaryKey Table",sidebar_position:1},r="PrimaryKey Table",d={},o=[{value:"Basic Concept",id:"basic-concept",level:2},{value:"Bucket Assigning",id:"bucket-assigning",level:2},{value:"Partial Update",id:"partial-update",level:2},{value:"Merge Engines",id:"merge-engines",level:2},{value:"Changelog Generation",id:"changelog-generation",level:2},{value:"Data Queries",id:"data-queries",level:2},{value:"Reads",id:"reads",level:3},{value:"Lookup",id:"lookup",level:3},{value:"Prefix Lookup",id:"prefix-lookup",level:3}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"primarykey-table",children:"PrimaryKey Table"})}),"\n",(0,s.jsx)(n.h2,{id:"basic-concept",children:"Basic Concept"}),"\n",(0,s.jsxs)(n.p,{children:["PrimaryKey Table in Fluss ensure the uniqueness of the specified primary key and supports ",(0,s.jsx)(n.code,{children:"INSERT"}),", ",(0,s.jsx)(n.code,{children:"UPDATE"}),",\nand ",(0,s.jsx)(n.code,{children:"DELETE"})," operations."]}),"\n",(0,s.jsxs)(n.p,{children:["A PrimaryKey Table is created by specifying a ",(0,s.jsx)(n.code,{children:"PRIMARY KEY"})," clause in the ",(0,s.jsx)(n.code,{children:"CREATE TABLE"})," statement. For example, the\nfollowing Flink SQL statement creates a PrimaryKey Table with ",(0,s.jsx)(n.code,{children:"shop_id"})," and ",(0,s.jsx)(n.code,{children:"user_id"})," as the primary key and distributes\nthe data into 4 buckets:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",metastring:'title="Flink SQL"',children:"CREATE TABLE pk_table\n(\n    shop_id      BIGINT,\n    user_id      BIGINT,\n    num_orders   INT,\n    total_amount INT,\n    PRIMARY KEY (shop_id, user_id) NOT ENFORCED\n) WITH (\n    'bucket.num' = '4'\n);\n"})}),"\n",(0,s.jsx)(n.p,{children:"In Fluss primary key table, each row of data has a unique primary key.\nIf multiple entries with the same primary key are written to the Fluss primary key table, only the last entry will be\nretained."}),"\n",(0,s.jsxs)(n.p,{children:["For ",(0,s.jsx)(n.a,{href:"/docs/next/table-design/data-distribution/partitioning",children:"Partitioned PrimaryKey Table"}),", the primary key must contain the\npartition key."]}),"\n",(0,s.jsx)(n.h2,{id:"bucket-assigning",children:"Bucket Assigning"}),"\n",(0,s.jsx)(n.p,{children:"For primary key tables, Fluss always determines which bucket the data belongs to based on the hash value of the bucket\nkey (It must be a subset of the primary keys excluding partition keys of the primary key table) for each record. If the bucket key is not specified, the bucket key will used as the primary key (excluding the partition key).\nData with the same hash value will be distributed to the same bucket."}),"\n",(0,s.jsx)(n.h2,{id:"partial-update",children:"Partial Update"}),"\n",(0,s.jsx)(n.p,{children:"For primary key tables, Fluss supports partial column updates, allowing you to write only a subset of columns to\nincrementally update the data and ultimately achieve complete data. Note that the columns being written must include the\nprimary key column."}),"\n",(0,s.jsx)(n.p,{children:"For example, consider the following Fluss primary key table:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",metastring:'title="Flink SQL"',children:"CREATE TABLE T\n(\n    k  INT,\n    v1 DOUBLE,\n    v2 STRING,\n    PRIMARY KEY (k) NOT ENFORCED\n);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Assuming that at the beginning, only the ",(0,s.jsx)(n.code,{children:"k"})," and ",(0,s.jsx)(n.code,{children:"v1"})," columns are written with the data ",(0,s.jsx)(n.code,{children:"+I(1, 2.0)"}),", ",(0,s.jsx)(n.code,{children:"+I(2, 3.0)"}),", the\ndata in T is as follows:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"k"}),(0,s.jsx)(n.th,{children:"v1"}),(0,s.jsx)(n.th,{children:"v2"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"2.0"}),(0,s.jsx)(n.td,{children:"null"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:"3.0"}),(0,s.jsx)(n.td,{children:"null"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["Then write to the ",(0,s.jsx)(n.code,{children:"k"})," and ",(0,s.jsx)(n.code,{children:"v2"})," columns with the data ",(0,s.jsx)(n.code,{children:"+I(1, 't1')"}),", ",(0,s.jsx)(n.code,{children:"+I(2, 't2')"}),", resulting in the data in T as\nfollows:"]}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"k"}),(0,s.jsx)(n.th,{children:"v1"}),(0,s.jsx)(n.th,{children:"v2"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"1"}),(0,s.jsx)(n.td,{children:"2.0"}),(0,s.jsx)(n.td,{children:"t1"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"2"}),(0,s.jsx)(n.td,{children:"3.0"}),(0,s.jsx)(n.td,{children:"t2"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"merge-engines",children:"Merge Engines"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"Merge Engine"})," in Fluss is a core component designed to efficiently handle and consolidate data updates for PrimaryKey Tables.\nIt offers users the flexibility to define how incoming data records are merged with existing records sharing the same primary key.\nHowever, users can specify a different merge engine to customize the merging behavior according to their specific use cases"]}),"\n",(0,s.jsx)(n.p,{children:"The following merge engines are supported:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/next/table-design/table-types/pk-table/merge-engines/default",children:"Default Merge Engine (LastRow)"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/next/table-design/table-types/pk-table/merge-engines/first-row",children:"FirstRow Merge Engine"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/docs/next/table-design/table-types/pk-table/merge-engines/versioned",children:"Versioned Merge Engine"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"changelog-generation",children:"Changelog Generation"}),"\n",(0,s.jsx)(n.p,{children:"Fluss will capture the changes when inserting, updating, deleting records on the primary-key table, which is known as\nthe changelog. Downstream consumers can directly consume the changelog to obtain the changes in the table. For example,\nconsider the following primary key table in Fluss:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",metastring:'title="Flink SQL"',children:"CREATE TABLE T\n(\n    k  INT,\n    v1 DOUBLE,\n    v2 STRING,\n    PRIMARY KEY (k) NOT ENFORCED\n);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If the data written to the primary-key table is\nsequentially ",(0,s.jsx)(n.code,{children:"+I(1, 2.0, 'apple')"}),", ",(0,s.jsx)(n.code,{children:"+I(1, 4.0, 'banana')"}),", ",(0,s.jsx)(n.code,{children:"-D(1, 4.0, 'banana')"}),", then the following change data will\nbe generated. For example, the following Flink SQL statements illustrate this behavior:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-sql",metastring:'title="Flink SQL"',children:"-- set to batch mode to execute DELETE and INSERT statements\nSET execution.runtime-mode = batch;\n\n-- insert to records with the same primary key k=1\nINSERT INTO T (k, v1) VALUES (1, 2.0,'apple');\nINSERT INTO T (k, v1) VALUES (1, 4.0,'banana');\n\n-- delete the record with primary key k=1\nDELETE FROM T WHERE k = 1;\n\n-- set to streaming mode to observe the changelogs\nSET execution.runtime-mode = streaming;\nSELECT * FROM T;\n"})}),"\n",(0,s.jsx)(n.p,{children:"Generate the following output in the Flink SQL CLI:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"| op   | k    | v1   | v2     |\n| ---- | ---- | ---- | ------ |\n| +I   | 1    | 2.0  | apple  |\n| -U   | 1    | 2.0  | apple  |\n| +U   | 1    | 4.0  | banana |\n| -D   | 1    | 4.0  | banana |\n"})}),"\n",(0,s.jsx)(n.h2,{id:"data-queries",children:"Data Queries"}),"\n",(0,s.jsx)(n.p,{children:"For primary key tables, Fluss supports various kinds of querying abilities."}),"\n",(0,s.jsx)(n.h3,{id:"reads",children:"Reads"}),"\n",(0,s.jsx)(n.p,{children:"For a primary key table, the default read method is a full snapshot followed by incremental data. First, the\nsnapshot data of the table is consumed, followed by the changelog data of the table."}),"\n",(0,s.jsxs)(n.p,{children:["It is also possible to only consume the changelog data of the table. For more details, please refer to the ",(0,s.jsx)(n.a,{href:"/docs/next/engine-flink/reads",children:"Flink Reads"})]}),"\n",(0,s.jsx)(n.h3,{id:"lookup",children:"Lookup"}),"\n",(0,s.jsxs)(n.p,{children:["Fluss primary key table can lookup data by the primary keys. If the key exists in Fluss, lookup will return a unique row. it always used in ",(0,s.jsx)(n.a,{href:"/docs/next/engine-flink/lookups#lookup",children:"Flink Lookup Join"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"prefix-lookup",children:"Prefix Lookup"}),"\n",(0,s.jsxs)(n.p,{children:["Fluss primary key table can also do prefix lookup by the prefix subset primary keys. Unlike lookup, prefix lookup\nwill scan data based on the prefix of primary keys and may return multiple rows. It always used in ",(0,s.jsx)(n.a,{href:"/docs/next/engine-flink/lookups#prefix-lookup",children:"Flink Prefix Lookup Join"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);