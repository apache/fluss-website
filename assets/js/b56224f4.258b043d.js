"use strict";(self.webpackChunkfluss_website=self.webpackChunkfluss_website||[]).push([[1428],{5727:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"maintenance/operations/racks","title":"Racks","description":"\x3c!--","source":"@site/docs/maintenance/operations/racks.md","sourceDirName":"maintenance/operations","slug":"/maintenance/operations/racks","permalink":"/docs/next/maintenance/operations/racks","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/fluss/edit/main/website/docs/maintenance/operations/racks.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Racks","sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Upgrading and Compatibility","permalink":"/docs/next/maintenance/operations/upgrading"},"next":{"title":"Security Overview","permalink":"/docs/next/security/overview"}}');var s=a(4848),t=a(8453);const i={title:"Racks",sidebar_position:2},o="Balancing Replicas Across Racks",c={},l=[];function d(e){const n={admonition:"admonition",code:"code",h1:"h1",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"balancing-replicas-across-racks",children:"Balancing Replicas Across Racks"})}),"\n",(0,s.jsx)(n.p,{children:"The rack awareness feature is designed to distribute replicas of the same bucket across multiple racks. This extends the\ndata protection guarantees provided by Fluss beyond server failures to include rack failures, thereby significantly\nreducing the risk of data loss in the event that all TabletServers on a single rack fail simultaneously."}),"\n",(0,s.jsxs)(n.p,{children:["To specify that a TabletServer belongs to a particular rack, you can set the ",(0,s.jsx)(n.code,{children:"tablet-server.rack"})," configuration option:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",metastring:'title="conf/server.yaml"',children:"tablet-server.rack: RACK1\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["If rack awareness is enabled, the ",(0,s.jsx)(n.code,{children:"tablet-server.rack"})," setting must be configured for each TabletServer. Failure to do so will prevent Fluss from starting and will result in an exception being thrown."]}),"\n"]})}),"\n",(0,s.jsxs)(n.p,{children:["When a table is created, the rack constraint is honored, ensuring that replicas are spread across as many racks as possible.\nSpecifically, a bucket will span the minimum of the number of available racks and the ",(0,s.jsx)(n.code,{children:"table.replication.factor"})," (i.e., ",(0,s.jsx)(n.code,{children:"min(#racks, table.replication.factor)"}),").\nThis approach maximizes the distribution of replicas across racks."]}),"\n",(0,s.jsx)(n.p,{children:"The algorithm used to assign replicas to TabletServers ensures that the number of leader replicas per TabletServer\nremains consistent, regardless of how TabletServers are distributed across racks. This helps maintain balanced throughput\nacross the system."}),"\n",(0,s.jsx)(n.p,{children:"However, if racks are assigned different numbers of TabletServers, the distribution of replicas will not be even. Racks\nwith fewer TabletServers will receive more replicas, leading to higher storage usage and increased resource allocation\nfor replication. Therefore, it is highly recommended to configure an equal number of TabletServers per rack to ensure\noptimal resource utilization and balanced workload distribution."})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>i,x:()=>o});var r=a(6540);const s={},t=r.createContext(s);function i(e){const n=r.useContext(t);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);