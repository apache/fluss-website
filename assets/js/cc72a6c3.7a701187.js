"use strict";(self.webpackChunkfluss_website=self.webpackChunkfluss_website||[]).push([[2905],{1470:(e,n,a)=>{a.d(n,{A:()=>w});var s=a(6540),t=a(4164),r=a(3104),i=a(6347),o=a(205),l=a(7485),c=a(1682),d=a(679);function u(e){return s.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function h(e){const{values:n,children:a}=e;return(0,s.useMemo)(()=>{const e=n??function(e){return u(e).map(({props:{value:e,label:n,attributes:a,default:s}})=>({value:e,label:n,attributes:a,default:s}))}(a);return function(e){const n=(0,c.XI)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,a])}function m({value:e,tabValues:n}){return n.some(n=>n.value===e)}function f({queryString:e=!1,groupId:n}){const a=(0,i.W6)(),t=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,l.aZ)(t),(0,s.useCallback)(e=>{if(!t)return;const n=new URLSearchParams(a.location.search);n.set(t,e),a.replace({...a.location,search:n.toString()})},[t,a])]}function p(e){const{defaultValue:n,queryString:a=!1,groupId:t}=e,r=h(e),[i,l]=(0,s.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!m({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const a=n.find(e=>e.default)??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:r})),[c,u]=f({queryString:a,groupId:t}),[p,S]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[a,t]=(0,d.Dv)(n);return[a,(0,s.useCallback)(e=>{n&&t.set(e)},[n,t])]}({groupId:t}),g=(()=>{const e=c??p;return m({value:e,tabValues:r})?e:null})();(0,o.A)(()=>{g&&l(g)},[g]);return{selectedValue:i,selectValue:(0,s.useCallback)(e=>{if(!m({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);l(e),u(e),S(e)},[u,S,r]),tabValues:r}}var S=a(2303);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var x=a(4848);function b({className:e,block:n,selectedValue:a,selectValue:s,tabValues:i}){const o=[],{blockElementScrollPositionUntilNextRender:l}=(0,r.a_)(),c=e=>{const n=e.currentTarget,t=o.indexOf(n),r=i[t].value;r!==a&&(l(n),s(r))},d=e=>{let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const a=o.indexOf(e.currentTarget)+1;n=o[a]??o[0];break}case"ArrowLeft":{const a=o.indexOf(e.currentTarget)-1;n=o[a]??o[o.length-1];break}}n?.focus()};return(0,x.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,t.A)("tabs",{"tabs--block":n},e),children:i.map(({value:e,label:n,attributes:s})=>(0,x.jsx)("li",{role:"tab",tabIndex:a===e?0:-1,"aria-selected":a===e,ref:e=>{o.push(e)},onKeyDown:d,onClick:c,...s,className:(0,t.A)("tabs__item",g.tabItem,s?.className,{"tabs__item--active":a===e}),children:n??e},e))})}function j({lazy:e,children:n,selectedValue:a}){const r=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=r.find(e=>e.props.value===a);return e?(0,s.cloneElement)(e,{className:(0,t.A)("margin-top--md",e.props.className)}):null}return(0,x.jsx)("div",{className:"margin-top--md",children:r.map((e,n)=>(0,s.cloneElement)(e,{key:n,hidden:e.props.value!==a}))})}function v(e){const n=p(e);return(0,x.jsxs)("div",{className:(0,t.A)("tabs-container",g.tabList),children:[(0,x.jsx)(b,{...n,...e}),(0,x.jsx)(j,{...n,...e})]})}function w(e){const n=(0,S.A)();return(0,x.jsx)(v,{...e,children:u(e.children)},String(n))}},2521:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>m,frontMatter:()=>l,metadata:()=>s,toc:()=>u});const s=JSON.parse('{"id":"engine-flink/datastream","title":"DataStream API","description":"\x3c!--","source":"@site/docs/engine-flink/datastream.mdx","sourceDirName":"engine-flink","slug":"/engine-flink/datastream","permalink":"/docs/next/engine-flink/datastream","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/fluss/edit/main/website/docs/engine-flink/datastream.mdx","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"title":"DataStream API","sidebar_position":6},"sidebar":"docsSidebar","previous":{"title":"Lookups","permalink":"/docs/next/engine-flink/lookups"},"next":{"title":"Connector Options","permalink":"/docs/next/engine-flink/options"}}');var t=a(4848),r=a(8453),i=a(1470),o=a(9365);const l={title:"DataStream API",sidebar_position:6},c="DataStream API",d={},u=[{value:"Overview",id:"overview",level:2},{value:"Dependency",id:"dependency",level:2},{value:"DataStream Source",id:"datastream-source",level:2},{value:"Initialization",id:"initialization",level:3},{value:"Configuration Options",id:"configuration-options",level:3},{value:"Required Parameters",id:"required-parameters",level:4},{value:"Optional Parameters",id:"optional-parameters",level:4},{value:"Offset Initializers",id:"offset-initializers",level:3},{value:"Deserialization Schemas",id:"deserialization-schemas",level:3},{value:"Examples",id:"examples",level:3},{value:"Reading from a Primary Key Table",id:"reading-from-a-primary-key-table",level:4},{value:"Reading from a Log Table",id:"reading-from-a-log-table",level:4},{value:"Using Projection Pushdown",id:"using-projection-pushdown",level:4},{value:"DataStream Sink",id:"datastream-sink",level:2},{value:"Initialization",id:"initialization-1",level:3},{value:"Configuration Options",id:"configuration-options-1",level:3},{value:"Required Parameters",id:"required-parameters-1",level:4},{value:"Optional Parameters",id:"optional-parameters-1",level:4},{value:"Examples",id:"examples-1",level:3},{value:"Writing to a Primary Key Table",id:"writing-to-a-primary-key-table",level:4},{value:"Writing to a Log Table",id:"writing-to-a-log-table",level:4},{value:"Setting Custom Configuration Options",id:"setting-custom-configuration-options",level:4},{value:"Serialization Schemas",id:"serialization-schemas",level:3}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"datastream-api",children:"DataStream API"})}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"The Fluss DataStream Connector for Apache Flink provides a Flink DataStream source implementation for reading data from Fluss tables and a Flink DataStream sink implementation for writing data to Fluss tables. It allows you to seamlessly integrate Fluss tables with Flink's DataStream API, enabling you to process data from Fluss in your Flink applications."}),"\n",(0,t.jsx)(n.p,{children:"Key features of the Fluss Datastream Connector include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Reading from both primary key tables and log tables"}),"\n",(0,t.jsx)(n.li,{children:"Support for projection pushdown to select specific fields"}),"\n",(0,t.jsx)(n.li,{children:"Flexible offset initialization strategies"}),"\n",(0,t.jsx)(n.li,{children:"Custom de/serialization schemas for converting between Fluss records and your data types"}),"\n",(0,t.jsx)(n.li,{children:"Writing to both primary key tables and log tables"}),"\n",(0,t.jsxs)(n.li,{children:["Support for different operation types (",(0,t.jsx)(n.code,{children:"INSERT"}),", ",(0,t.jsx)(n.code,{children:"UPDATE"}),", ",(0,t.jsx)(n.code,{children:"DELETE"}),")"]}),"\n",(0,t.jsx)(n.li,{children:"Configurable sink behavior with custom options"}),"\n",(0,t.jsx)(n.li,{children:"Automatic handling of upserts for primary key tables"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"dependency",children:"Dependency"}),"\n",(0,t.jsxs)(n.p,{children:["In order to use the Fluss DataStream Connector in Flink DataStream API, you need to add the following dependency to your ",(0,t.jsx)(n.code,{children:"pom.xml"})," file,\naccording to the Flink version you are using. The Fluss DataStream Connector is available for Flink versions 1.18, 1.19, and 1.20."]}),"\n","\n",(0,t.jsxs)(i.A,{children:[(0,t.jsx)(o.A,{value:"flink-1.20",label:"Flink 1.20",default:!0,children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:"\x3c!-- https://mvnrepository.com/artifact/com.alibaba.fluss/fluss-flink-1.20 --\x3e\n<dependency>\n    <groupId>com.alibaba.fluss</groupId>\n    <artifactId>fluss-flink-1.20</artifactId>\n    <version>0.8-SNAPSHOT</version>\n</dependency>\n"})})}),(0,t.jsx)(o.A,{value:"flink-1.19",label:"Flink 1.19",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:"\x3c!-- https://mvnrepository.com/artifact/com.alibaba.fluss/fluss-flink-1.19 --\x3e\n<dependency>\n    <groupId>com.alibaba.fluss</groupId>\n    <artifactId>fluss-flink-1.19</artifactId>\n    <version>0.8-SNAPSHOT</version>\n</dependency>\n"})})}),(0,t.jsx)(o.A,{value:"flink-1.18",label:"Flink 1.18",children:(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:"\x3c!-- https://mvnrepository.com/artifact/com.alibaba.fluss/fluss-flink-1.18 --\x3e\n<dependency>\n    <groupId>com.alibaba.fluss</groupId>\n    <artifactId>fluss-flink-1.18</artifactId>\n    <version>0.8-SNAPSHOT</version>\n</dependency>\n"})})})]}),"\n",(0,t.jsx)(n.h2,{id:"datastream-source",children:"DataStream Source"}),"\n",(0,t.jsx)(n.h3,{id:"initialization",children:"Initialization"}),"\n",(0,t.jsxs)(n.p,{children:["The main entry point for the Fluss DataStream API is the ",(0,t.jsx)(n.code,{children:"FlussSource"})," class. You create a ",(0,t.jsx)(n.code,{children:"FlussSource"})," instance using the builder pattern, which allows for step-by-step configuration of the source connector."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Create a FlussSource using the builder pattern\nFlussSource<Order> flussSource = FlussSource.<Order>builder()\n    .setBootstrapServers("localhost:9123")\n    .setDatabase("mydb")\n    .setTable("orders")\n    .setProjectedFields("orderId", "amount")\n    .setStartingOffsets(OffsetsInitializer.earliest())\n    .setScanPartitionDiscoveryIntervalMs(1000L)\n    .setDeserializationSchema(new OrderDeserializationSchema())\n    .build();\n\nDataStreamSource<Order> stream =\n        env.fromSource(flussSource, WatermarkStrategy.noWatermarks(), "Fluss Orders Source");\n\nstream.print();\n'})}),"\n",(0,t.jsx)(n.h3,{id:"configuration-options",children:"Configuration Options"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"FlussSourceBuilder"})," provides several methods for configuring the source connector:"]}),"\n",(0,t.jsx)(n.h4,{id:"required-parameters",children:"Required Parameters"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"setBootstrapServers(String bootstrapServers):"})," Sets the bootstrap servers for the Fluss source connection"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"setDatabase(String database):"})," Sets the database name for the Fluss source"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"setTable(String table):"})," Sets the table name for the Fluss source"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"setDeserializationSchema(FlussDeserializationSchema<T> schema):"})," Sets the deserialization schema for converting Fluss records to output records"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"optional-parameters",children:"Optional Parameters"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"setProjectedFields(String... projectedFieldNames):"})," Sets the fields to project from the table (if not specified, all fields are included)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"setScanPartitionDiscoveryIntervalMs(long intervalMs):"})," Sets the interval for discovering new partitions (default: from configuration)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"setStartingOffsets(OffsetsInitializer initializer):"})," Sets the strategy for determining starting offsets (default: ",(0,t.jsx)(n.code,{children:"OffsetsInitializer.full()"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"setFlussConfig(Configuration flussConf):"})," Sets custom Fluss configuration properties"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"offset-initializers",children:"Offset Initializers"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"OffsetsInitializer"})," interface provides several factory methods for creating different types of initializers:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"OffsetsInitializer.earliest():"})," Initializes offsets to the earliest available offsets of each bucket"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"OffsetsInitializer.latest():"})," Initializes offsets to the latest offsets of each bucket"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"OffsetsInitializer.full():"})," Performs a full snapshot on the table upon first startup:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["For ",(0,t.jsx)(n.strong,{children:"log tables:"})," reads from the earliest log offset (equivalent to earliest())"]}),"\n",(0,t.jsxs)(n.li,{children:["For ",(0,t.jsx)(n.strong,{children:"primary key tables:"})," reads the latest snapshot which materializes all changes on the table"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"OffsetsInitializer.timestamp(long timestamp):"})," Initializes offsets based on a given timestamp"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Start reading from the earliest available offsets\nFlussSource<Order> source = FlussSource.<Order>builder()\n    .setStartingOffsets(OffsetsInitializer.earliest())\n    // other configuration...\n    .build();\n\n// Start reading from the latest offsets\nFlussSource<Order> source = FlussSource.<Order>builder()\n    .setStartingOffsets(OffsetsInitializer.latest())\n    // other configuration...\n    .build();\n\n// Start reading from a specific timestamp\nFlussSource<Order> source = FlussSource.<Order>builder()\n    .setStartingOffsets(OffsetsInitializer.timestamp(System.currentTimeMillis() - 3600 * 1000))\n    // other configuration...\n    .build();\n"})}),"\n",(0,t.jsx)(n.h3,{id:"deserialization-schemas",children:"Deserialization Schemas"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"FlussDeserializationSchema"})," interface is used to convert Fluss records to your desired output type. Fluss provides some built-in implementations:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"RowDataDeserializationSchema"})," - Converts Fluss records to Flink's ",(0,t.jsx)(n.code,{children:"RowData"})," objects"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"JsonStringDeserializationSchema"})," - Converts Fluss records to JSON strings"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["You can also implement your own deserialization schema by implementing the ",(0,t.jsx)(n.code,{children:"FlussDeserializationSchema"})," interface:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"public class OrderDeserializationSchema implements FlussDeserializationSchema<Order> {\n    @Override\n    public void open(InitializationContext context) throws Exception {\n        // Initialization code if needed\n    }\n\n    @Override\n    public Order deserialize(LogRecord record) throws Exception {\n        InternalRow row = record.getRow();\n\n        // Extract fields from the row\n        long orderId = row.getLong(0);\n        long itemId = row.getLong(1);\n        int amount = row.getInt(2);\n        String address = row.getString(3).toString();\n\n        // Create and return your custom object\n        return new Order(orderId, itemId, amount, address);\n    }\n\n    @Override\n    public TypeInformation<Order> getProducedType(RowType rowSchema) {\n        return TypeInformation.of(Order.class);\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"examples",children:"Examples"}),"\n",(0,t.jsx)(n.h4,{id:"reading-from-a-primary-key-table",children:"Reading from a Primary Key Table"}),"\n",(0,t.jsxs)(n.p,{children:["When reading from a primary key table, the Fluss DataStream Connector automatically handles updates to the data.\nFor each update, it emits both the before and after versions of the record with the appropriate ",(0,t.jsx)(n.code,{children:"RowKind"})," (",(0,t.jsx)(n.code,{children:"INSERT"}),", ",(0,t.jsx)(n.code,{children:"UPDATE_BEFORE"}),", ",(0,t.jsx)(n.code,{children:"UPDATE_AFTER"}),", ",(0,t.jsx)(n.code,{children:"DELETE"}),")."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Create a FlussSource for a primary key table\nFlussSource<RowData> flussSource = FlussSource.<RowData>builder()\n    .setBootstrapServers("localhost:9123")\n    .setDatabase("mydb")\n    .setTable("orders_pk")\n    .setStartingOffsets(OffsetsInitializer.earliest())\n    .setDeserializationSchema(new RowDataDeserializationSchema())\n    .build();\n\n// Create a DataStream from the FlussSource\nDataStreamSource<RowData> stream = env.fromSource(\n    flussSource,\n    WatermarkStrategy.noWatermarks(),\n    "Fluss PK Source"\n);\n\n// Process the stream to handle different row kinds\n// For INSERT, UPDATE_BEFORE, UPDATE_AFTER, DELETE events\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note:"})," If you are mapping from ",(0,t.jsx)(n.code,{children:"RowData"})," to your pojos object, you might want to include the row kind operation."]}),"\n",(0,t.jsx)(n.h4,{id:"reading-from-a-log-table",children:"Reading from a Log Table"}),"\n",(0,t.jsxs)(n.p,{children:["When reading from a log table, all records are emitted with ",(0,t.jsx)(n.code,{children:"RowKind.INSERT"})," since log tables only support appends."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Create a FlussSource for a log table\nFlussSource<RowData> flussSource = FlussSource.<RowData>builder()\n    .setBootstrapServers("localhost:9123")\n    .setDatabase("mydb")\n    .setTable("orders_log")\n    .setStartingOffsets(OffsetsInitializer.earliest())\n    .setDeserializationSchema(new RowDataDeserializationSchema())\n    .build();\n\n// Create a DataStream from the FlussSource\nDataStreamSource<RowData> stream = env.fromSource(\n    flussSource,\n    WatermarkStrategy.noWatermarks(),\n    "Fluss Log Source"\n);\n'})}),"\n",(0,t.jsx)(n.h4,{id:"using-projection-pushdown",children:"Using Projection Pushdown"}),"\n",(0,t.jsx)(n.p,{children:"Projection pushdown allows you to select only the fields you need, which can improve performance by reducing the amount of data transferred."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Create a FlussSource with projection pushdown\nFlussSource<OrderPartial> flussSource = FlussSource.<OrderPartial>builder()\n    .setBootstrapServers("localhost:9123")\n    .setDatabase("mydb")\n    .setTable("orders")\n    .setProjectedFields("orderId", "amount")  // Only select these fields\n    .setStartingOffsets(OffsetsInitializer.earliest())\n    .setDeserializationSchema(new OrderPartialDeserializationSchema())\n    .build();\n\n// Create a DataStream from the FlussSource\nDataStreamSource<OrderPartial> stream = env.fromSource(\n    flussSource,\n    WatermarkStrategy.noWatermarks(),\n    "Fluss Source with Projection"\n);\n'})}),"\n",(0,t.jsxs)(n.p,{children:["In this example, ",(0,t.jsx)(n.code,{children:"OrderPartial"})," is a class that only contains the ",(0,t.jsx)(n.code,{children:"orderId"})," and ",(0,t.jsx)(n.code,{children:"amount"})," fields, and ",(0,t.jsx)(n.code,{children:"OrderPartialDeserializationSchema"})," is a deserialization schema that knows how to convert the projected fields to ",(0,t.jsx)(n.code,{children:"OrderPartial"})," objects."]}),"\n",(0,t.jsx)(n.h2,{id:"datastream-sink",children:"DataStream Sink"}),"\n",(0,t.jsx)(n.h3,{id:"initialization-1",children:"Initialization"}),"\n",(0,t.jsxs)(n.p,{children:["The main entry point for the Fluss DataStream Sink API is the ",(0,t.jsx)(n.code,{children:"FlussSink"})," class. You create a ",(0,t.jsx)(n.code,{children:"FlussSink"})," instance using the ",(0,t.jsx)(n.code,{children:"FlussSinkBuilder"}),", which allows for step-by-step configuration of the sink connector."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'FlussSink<RowData> flussSink =\n        FlussSink.<RowData>builder()\n                .setBootstrapServers("localhost:9123")\n                .setDatabase("mydb")\n                .setTable("orders")\n                .setSerializationSchema(new RowDataSerializationSchema(false, true))\n                .build();\n\nstream.sinkTo(flussSink).name("Fluss Sink");\n'})}),"\n",(0,t.jsx)(n.h3,{id:"configuration-options-1",children:"Configuration Options"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"FlussSinkBuilder"})," provides several methods for configuring the sink connector:"]}),"\n",(0,t.jsx)(n.h4,{id:"required-parameters-1",children:"Required Parameters"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"setBootstrapServers(String bootstrapServers):"})," Sets the bootstrap servers for the Fluss sink connection"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"setDatabase(String database):"})," Sets the database name for the Fluss sink"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"setTable(String table):"})," Sets the table name for the Fluss sink"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"setSerializationSchema(FlussSerializationSchema<T> schema):"})," Sets the serialization schema for converting input records to Fluss records"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"optional-parameters-1",children:"Optional Parameters"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"setShuffleByBucketId(boolean shuffleByBucketId):"})," Sets whether to shuffle data by bucket ID (default: true)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"setOption(String key, String value):"})," Sets a single configuration option"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"setOptions(Map<String, String> options):"})," Sets multiple configuration options at once"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Note:"})," ",(0,t.jsx)(n.code,{children:"FlussSerializationSchema"})," needs to propagate downstream the operations that take place. See ",(0,t.jsx)(n.a,{href:"https://github.com/alibaba/fluss/blob/main/fluss-flink/fluss-flink-common/src/main/java/com/alibaba/fluss/flink/sink/serializer/RowDataSerializationSchema.java",children:"RowDataSerializationSchema"})," as an example."]}),"\n",(0,t.jsx)(n.h3,{id:"examples-1",children:"Examples"}),"\n",(0,t.jsx)(n.h4,{id:"writing-to-a-primary-key-table",children:"Writing to a Primary Key Table"}),"\n",(0,t.jsx)(n.p,{children:"When writing to a primary key table, the Fluss DataStream Connector automatically handles upserts based on the primary key."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Create a FlussSink for a primary key table\nFlussSink<Order> flussSink = FlussSink.<Order>builder()\n                .setBootstrapServers("localhost:9123")\n                .setDatabase("mydb")\n                .setTable("orders_pk")\n                .setSerializationSchema(new OrderSerializationSchema())\n                .build();\n\n// Add the sink to your DataStream\ndataStream.sinkTo(flussSink);\n'})}),"\n",(0,t.jsx)(n.h4,{id:"writing-to-a-log-table",children:"Writing to a Log Table"}),"\n",(0,t.jsx)(n.p,{children:"When writing to a log table, all records are appended."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Create a FlussSink for a log table\nFlussSink<Order> flussSink = FlussSink.<Order>builder()\n                .setBootstrapServers("localhost:9123")\n                .setDatabase("mydb")\n                .setTable("orders_log")\n                .setSerializationSchema(new OrderSerializationSchema())\n                .build();\n\n// Add the sink to your DataStream\ndataStream.sinkTo(flussSink);\n'})}),"\n",(0,t.jsx)(n.h4,{id:"setting-custom-configuration-options",children:"Setting Custom Configuration Options"}),"\n",(0,t.jsx)(n.p,{children:"You can set custom configuration options for the Fluss sink."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'// Create a FlussSink with custom configuration options\nFlussSink<Order> flussSink = FlussSink.<Order>builder()\n                .setBootstrapServers("localhost:9123")\n                .setDatabase("mydb")\n                .setTable("orders")\n                .setOption("custom.key", "custom.value")\n                .setSerializationSchema(new OrderSerializationSchema())\n                .build();\n\n// Or set multiple options at once\nMap<String, String> options = new HashMap<>();\noptions.put("option1", "value1");\noptions.put("option2", "value2");\n\nFlussSink<Order> flussSink = FlussSink.<Order>builder()\n        .setBootstrapServers("localhost:9123")\n        .setDatabase("mydb")\n        .setTable("orders")\n        .setOptions(options)\n        .setSerializationSchema(new OrderSerializationSchema())\n        .build();\n'})}),"\n",(0,t.jsx)(n.h3,{id:"serialization-schemas",children:"Serialization Schemas"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"FlussSerializationSchema"})," interface is used to convert your data objects to Fluss's internal row format for writing to Fluss tables. Fluss provides built-in implementations:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"RowDataSerializationSchema"})," - Converts Flink's ",(0,t.jsx)(n.code,{children:"RowData"})," objects to Fluss rows"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"JsonStringSerializationSchema"})," - Converts JSON strings to Fluss rows"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The serialization schema is used when writing data to Fluss tables using the Fluss sink. When configuring a Fluss sink, you provide a serialization schema that converts your data objects to Fluss's internal row format. The serialization schema is set using the ",(0,t.jsx)(n.code,{children:"setSerializationSchema()"})," method on the sink builder."]}),"\n",(0,t.jsxs)(n.p,{children:["You can implement your own serialization schema by implementing the ",(0,t.jsx)(n.code,{children:"FlussSerializationSchema"})," interface:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'private static class Order implements Serializable {\n  private static final long serialVersionUID = 1L;\n  private final long orderId;\n  private final long itemId;\n  private final int amount;\n  private final String address;\n  private final RowKind rowKind; // holds the row operation\n\n  ...\n}\n\nprivate static class OrderSerializationSchema\n            implements FlussSerializationSchema<Order> {\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public void open(InitializationContext context) throws Exception {}\n\n        @Override\n        public RowWithOp serialize(Order value) throws Exception {\n            GenericRow row = new GenericRow(4);\n            row.setField(0, value.orderId);\n            row.setField(1, value.itemId);\n            row.setField(2, value.amount);\n            row.setField(3, BinaryString.fromString(value.address));\n\n            RowKind rowKind = value.rowKind;\n            switch (rowKind) {\n                case INSERT:\n                case UPDATE_AFTER:\n                    return new RowWithOp(row, OperationType.UPSERT);\n                case UPDATE_BEFORE:\n                case DELETE:\n                    return new RowWithOp(row, OperationType.DELETE);\n                default:\n                    throw new IllegalArgumentException("Unsupported row kind: " + rowKind);\n            }\n        }\n    }\n'})}),"\n",(0,t.jsxs)(n.p,{children:["By default you can use the ",(0,t.jsx)(n.a,{href:"https://github.com/alibaba/fluss/blob/main/fluss-flink/fluss-flink-common/src/main/java/com/alibaba/fluss/flink/sink/serializer/RowDataSerializationSchema.java",children:"RowDataSerializationSchema"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"RowDataSerializationSchema"})," provides additional configuration options:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"isAppendOnly"})," - Whether the schema operates in append-only mode (only INSERT operations)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"ignoreDelete"})," - Whether to ignore ",(0,t.jsx)(n.code,{children:"DELETE"})," and ",(0,t.jsx)(n.code,{children:"UPDATE_BEFORE"})," operations"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:"// Create a serialization schema for append-only operations\nRowDataSerializationSchema schema = new RowDataSerializationSchema(true, false);\n\n// Create a serialization schema that handles all operation types\nRowDataSerializationSchema schema = new RowDataSerializationSchema(false, false);\n\n// Create a serialization schema that ignores DELETE operations\nRowDataSerializationSchema schema = new RowDataSerializationSchema(false, true);\n"})})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>i,x:()=>o});var s=a(6540);const t={},r=s.createContext(t);function i(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(r.Provider,{value:n},e.children)}},9365:(e,n,a)=>{a.d(n,{A:()=>i});a(6540);var s=a(4164);const t={tabItem:"tabItem_Ymn6"};var r=a(4848);function i({children:e,hidden:n,className:a}){return(0,r.jsx)("div",{role:"tabpanel",className:(0,s.A)(t.tabItem,a),hidden:n,children:e})}}}]);