"use strict";(self.webpackChunkfluss_website=self.webpackChunkfluss_website||[]).push([[4689],{8453:(e,t,s)=>{s.d(t,{R:()=>o,x:()=>r});var n=s(6540);const i={},a=n.createContext(i);function o(e){const t=n.useContext(a);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(a.Provider,{value:t},e.children)}},8572:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"table-design/table-types/log-table","title":"Log Table","description":"Basic Concept","source":"@site/versioned_docs/version-0.5/table-design/table-types/log-table.md","sourceDirName":"table-design/table-types","slug":"/table-design/table-types/log-table","permalink":"/docs/0.5/table-design/table-types/log-table","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/fluss/edit/main/website/docs/table-design/table-types/log-table.md","tags":[],"version":"0.5","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"Overview","permalink":"/docs/0.5/table-design/overview"},"next":{"title":"PrimaryKey Table","permalink":"/docs/0.5/table-design/table-types/pk-table"}}');var i=s(4848),a=s(8453);const o={sidebar_position:1},r="Log Table",l={},c=[{value:"Basic Concept",id:"basic-concept",level:2},{value:"Bucket Assigning",id:"bucket-assigning",level:2},{value:"Data Consumption",id:"data-consumption",level:2},{value:"Log Tiering",id:"log-tiering",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"log-table",children:"Log Table"})}),"\n",(0,i.jsx)(t.h2,{id:"basic-concept",children:"Basic Concept"}),"\n",(0,i.jsx)(t.p,{children:"Log Table is a type of table in Fluss that is used to store data in the order in which it was written. Log Table only supports append records, and doesn't support Update/Delete operations.\nUsually, Log Table is used to store logs in very high-throughput, like the typical use cases of Apache Kafka."}),"\n",(0,i.jsxs)(t.p,{children:["Log Table is created by not specifying the ",(0,i.jsx)(t.code,{children:"PRIMARY KEY"})," clause in the ",(0,i.jsx)(t.code,{children:"CREATE TABLE"})," statement. For example, the following Flink SQL statement will create a log table with 3 buckets."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sql",metastring:'title="Flink SQL"',children:"CREATE TABLE log_table (\n  order_id BIGINT,\n  item_id BIGINT,\n  amount INT,\n  address STRING\n)\nWITH ('bucket.num' = '3');\n"})}),"\n",(0,i.jsx)(t.admonition,{type:"note",children:(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"bucket.num"})," should be a positive integer. If this value is not provided, a default value from the cluster will be used as the bucket number for the table."]})}),"\n",(0,i.jsx)(t.h2,{id:"bucket-assigning",children:"Bucket Assigning"}),"\n",(0,i.jsxs)(t.p,{children:["Bucketing is the fundamental unit of parallelism and scalability in Fluss.  A single table in Fluss is divided into multiple buckets. A bucket is the smallest storage unit for reads and writes. See more details about ",(0,i.jsx)(t.a,{href:"/docs/0.5/table-design/data-distribution/bucketing",children:"Bucketing"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"When writing records into log table, Fluss will assign each record to a specific bucket based on the bucket assigning strategy. There are 3 strategies for bucket assigning in Fluss:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Sticky Bucket Strategy"}),": As the default strategy, randomly select a bucket and consistently write into that bucket until a record batch is full. Sets ",(0,i.jsx)(t.code,{children:"client.writer.bucket.no-key-assigner=sticky"})," to the table property to enable this strategy."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Round-Robin Strategy"}),": Select a bucket in round-robin for each record before writing it in. Sets ",(0,i.jsx)(t.code,{children:"client.writer.bucket.no-key-assigner=round_robin"})," to the table property to enable this strategy."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Hash-based Bucketing"}),": If ",(0,i.jsx)(t.code,{children:"bucket.key"})," property is set in the table property, Fluss will determine to assign records to bucket based on the hash value of the specified bucket keys, and the property ",(0,i.jsx)(t.code,{children:"client.writer.bucket.no-key-assigner"})," will be ignored. For example, setting ",(0,i.jsx)(t.code,{children:"'bucket.key' = 'c1,c2'"})," will assign buckets based on the values of columns ",(0,i.jsx)(t.code,{children:"c1"})," and ",(0,i.jsx)(t.code,{children:"c2"}),". Different column names should be separated by commas."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"data-consumption",children:"Data Consumption"}),"\n",(0,i.jsx)(t.p,{children:"Log Tables in Fluss allow real-time data consumption, preserving the order of data within each bucket as it was written to the Fluss table. Specifically:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"For two data records from the same table and the same bucket, the data that was written to the Fluss table first will be consumed first."}),"\n",(0,i.jsx)(t.li,{children:"For two data records from the same partition but different buckets, the consumption order is not guaranteed because different buckets may be processed concurrently by different data consumption jobs."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"log-tiering",children:"Log Tiering"}),"\n",(0,i.jsxs)(t.p,{children:["Log Table supports tiering data to different storage tiers. See more details about ",(0,i.jsx)(t.a,{href:"/docs/0.5/maintenance/tiered-storage/remote-storage",children:"Remote Log"}),"."]})]})}function u(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);