"use strict";(self.webpackChunkfluss_website=self.webpackChunkfluss_website||[]).push([[2791],{6951:(t,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"table-design/data-distribution/partitioning","title":"Partitioning","description":"\x3c!--","source":"@site/docs/table-design/data-distribution/partitioning.md","sourceDirName":"table-design/data-distribution","slug":"/table-design/data-distribution/partitioning","permalink":"/docs/next/table-design/data-distribution/partitioning","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/fluss/edit/main/website/docs/table-design/data-distribution/partitioning.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"title":"Partitioning","sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Bucketing","permalink":"/docs/next/table-design/data-distribution/bucketing"},"next":{"title":"TTL","permalink":"/docs/next/table-design/data-distribution/ttl"}}');var a=i(4848),r=i(8453);const s={title:"Partitioning",sidebar_position:2},o="Partitioning",l={},d=[{value:"Partitioned Tables",id:"partitioned-tables",level:2},{value:"Multi-Field Partitioned Tables",id:"multi-field-partitioned-tables",level:3},{value:"Key Benefits of Partitioned Tables",id:"key-benefits-of-partitioned-tables",level:3},{value:"Restrictions",id:"restrictions",level:2},{value:"Auto Partitioning",id:"auto-partitioning",level:2},{value:"Example",id:"example",level:3},{value:"Table Options",id:"table-options",level:3},{value:"Partition Generation Rules",id:"partition-generation-rules",level:3},{value:"Fluss Cluster Configuration",id:"fluss-cluster-configuration",level:3},{value:"Dynamic Partitioning",id:"dynamic-partitioning",level:2},{value:"Client Options",id:"client-options",level:3}];function c(t){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...t.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"partitioning",children:"Partitioning"})}),"\n",(0,a.jsx)(e.h2,{id:"partitioned-tables",children:"Partitioned Tables"}),"\n",(0,a.jsxs)(e.p,{children:["In Fluss, a ",(0,a.jsx)(e.strong,{children:"Partitioned Table"})," organizes data based on one or more partition keys, providing a way to improve query performance and manageability for large datasets. Partitions allow the system to divide data into distinct segments, each corresponding to specific values of the partition keys."]}),"\n",(0,a.jsx)(e.p,{children:"For partitioned tables, Fluss supports three strategies of managing partitions."}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Manual management partitions"}),", user can create new partitions or drop exists partitions. Learn how to create or drop partitions please refer to ",(0,a.jsx)(e.a,{href:"/docs/next/engine-flink/ddl#add-partition",children:"Add Partition"})," and ",(0,a.jsx)(e.a,{href:"/docs/next/engine-flink/ddl#drop-partition",children:"Drop Partition"}),"."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Auto management partitions"}),", the partitions will be created based on the auto partitioning rules configured at the time of table creation, and expired partitions are automatically removed, ensuring data not expanding unlimited. See ",(0,a.jsx)(e.a,{href:"/docs/next/table-design/data-distribution/partitioning#auto-partitioning",children:"Auto Partitioning"}),"."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Dynamic create partitions"}),", the partitions will be created automatically based on the data being written to the table. See ",(0,a.jsx)(e.a,{href:"/docs/next/table-design/data-distribution/partitioning#dynamic-partitioning",children:"Dynamic Partitioning"}),"."]}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"These three strategies are orthogonal and can coexist on the same table."}),"\n",(0,a.jsx)(e.h3,{id:"multi-field-partitioned-tables",children:"Multi-Field Partitioned Tables"}),"\n",(0,a.jsx)(e.p,{children:"Partitioned tables (either primary-key table or log table) support configuring partition keys based on multiple fields. This allows users to segment data using combinations of field values, enabling more granular data organization, management, and query optimization."}),"\n",(0,a.jsxs)(e.p,{children:["For example, in an ",(0,a.jsx)(e.code,{children:"Order"})," primary key table, the partition key can be defined as ",(0,a.jsx)(e.code,{children:"(date, region)"}),". Data will then be stored in partitions corresponding to specific combinations such as ",(0,a.jsx)(e.code,{children:"date=2025-04-05, region=US"}),". Users can leverage partition pruning during streaming queries \u2014 such as filtering by ",(0,a.jsx)(e.code,{children:"region=US"})," \u2014 to improve read performance through partition pushdown."]}),"\n",(0,a.jsx)(e.h3,{id:"key-benefits-of-partitioned-tables",children:"Key Benefits of Partitioned Tables"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Improved Query Performance:"})," By narrowing down the query scope to specific partitions, the system reads fewer data, reducing query execution time."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Data Organization:"})," Partitions help in logically organizing data, making it easier to manage and query."]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Scalability:"})," Partitioning large datasets distributes the data across smaller, manageable chunks, improving scalability."]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"restrictions",children:"Restrictions"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"The type of the partition keys must be STRING."}),"\n",(0,a.jsx)(e.li,{children:"For auto partition table, the partition keys can be one or more. If the table has only one partition key, it supports automatic creation and automatic expiration of partitions. Otherwise, only automatic expiration is allowed."}),"\n",(0,a.jsx)(e.li,{children:"If the table is a primary key table, the partition key must be a subset of the primary key."}),"\n",(0,a.jsx)(e.li,{children:"Auto-partitioning rules can only be configured at the time of creating the partitioned table; modifying the auto-partitioning rules after table creation is not supported."}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"auto-partitioning",children:"Auto Partitioning"}),"\n",(0,a.jsx)(e.h3,{id:"example",children:"Example"}),"\n",(0,a.jsxs)(e.p,{children:["The auto-partitioning rules are configured through table options. The following example demonstrates creating a table named ",(0,a.jsx)(e.code,{children:"site_access"})," that supports automatic partitioning using Flink SQL."]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-sql",metastring:'title="Flink SQL"',children:"CREATE TABLE site_access(\n  event_day STRING,\n  site_id INT,\n  city_code STRING,\n  user_name STRING,\n  pv BIGINT,\n  PRIMARY KEY(event_day, site_id) NOT ENFORCED \n) PARTITIONED BY (event_day) WITH (\n  'table.auto-partition.enabled' = 'true',\n  'table.auto-partition.time-unit' = 'YEAR',\n  'table.auto-partition.num-precreate' = '5',\n  'table.auto-partition.num-retention' = '2',\n  'table.auto-partition.time-zone' = 'Asia/Shanghai'\n);\n"})}),"\n",(0,a.jsx)(e.p,{children:"In this case, when automatic partitioning occurs (Fluss will periodically operate on all tables in the background), four partitions are pre-created with a partition granularity of YEAR, retaining two historical partitions. The time zone is set to Asia/Shanghai."}),"\n",(0,a.jsx)(e.h3,{id:"table-options",children:"Table Options"}),"\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"Option"}),(0,a.jsx)(e.th,{children:"Type"}),(0,a.jsx)(e.th,{children:"Required"}),(0,a.jsx)(e.th,{children:"Default"}),(0,a.jsx)(e.th,{children:"Description"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"table.auto-partition.enabled"}),(0,a.jsx)(e.td,{children:"Boolean"}),(0,a.jsx)(e.td,{children:"no"}),(0,a.jsx)(e.td,{children:"false"}),(0,a.jsx)(e.td,{children:"Whether enable auto partition for the table. Disable by default. When auto partition is enabled, the partitions of the table will be created automatically."})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"table.auto-partition.key"}),(0,a.jsx)(e.td,{children:"String"}),(0,a.jsx)(e.td,{children:"no"}),(0,a.jsx)(e.td,{children:"(none)"}),(0,a.jsx)(e.td,{children:"This configuration defines the time-based partition key to be used for auto-partitioning when a table is partitioned with multiple keys. Auto-partitioning utilizes a time-based partition key to handle partitions automatically, including creating new ones and removing outdated ones, by comparing the time value of the partition with the current system time. In the case of a table using multiple partition keys (such as a composite partitioning strategy), this feature determines which key should serve as the primary time dimension for making auto-partitioning decisions. And If the table has only one partition key, this config is not necessary. Otherwise, it must be specified."})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"table.auto-partition.time-unit"}),(0,a.jsx)(e.td,{children:"ENUM"}),(0,a.jsx)(e.td,{children:"no"}),(0,a.jsx)(e.td,{children:"DAY"}),(0,a.jsx)(e.td,{children:"The time granularity for auto created partitions. The default value is 'DAY'. Valid values are 'HOUR', 'DAY', 'MONTH', 'QUARTER', 'YEAR'. If the value is 'HOUR', the partition format for auto created is yyyyMMddHH. If the value is 'DAY', the partition format for auto created is yyyyMMdd. If the value is 'MONTH', the partition format for auto created is yyyyMM. If the value is 'QUARTER', the partition format for auto created is yyyyQ. If the value is 'YEAR', the partition format for auto created is yyyy."})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"table.auto-partition.num-precreate"}),(0,a.jsx)(e.td,{children:"Integer"}),(0,a.jsx)(e.td,{children:"no"}),(0,a.jsx)(e.td,{children:"2"}),(0,a.jsx)(e.td,{children:"The number of partitions to pre-create for auto created partitions in each check for auto partition. For example, if the current check time is 2024-11-11 and the value is configured as 3, then partitions 20241111, 20241112, 20241113 will be pre-created. If any one partition exists, it'll skip creating the partition. The default value is 2, which means 2 partitions will be pre-created. If the 'table.auto-partition.time-unit' is 'DAY'(default), one precreated partition is for today and another one is for tomorrow. For a partition table with multiple partition keys, pre-create is unsupported and will be set to 0 automatically when creating table if it is not explicitly specified."})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"table.auto-partition.num-retention"}),(0,a.jsx)(e.td,{children:"Integer"}),(0,a.jsx)(e.td,{children:"no"}),(0,a.jsx)(e.td,{children:"7"}),(0,a.jsx)(e.td,{children:"The number of history partitions to retain for auto created partitions in each check for auto partition. For example, if the current check time is 2024-11-11, time-unit is DAY, and the value is configured as 3, then the history partitions 20241108, 20241109, 20241110 will be retained. The partitions earlier than 20241108 will be deleted. The default value is 7."})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"table.auto-partition.time-zone"}),(0,a.jsx)(e.td,{children:"String"}),(0,a.jsx)(e.td,{children:"no"}),(0,a.jsx)(e.td,{children:"the system time zone"}),(0,a.jsx)(e.td,{children:"The time zone for auto partitions, which is by default the same as the system time zone."})]})]})]}),"\n",(0,a.jsx)(e.h3,{id:"partition-generation-rules",children:"Partition Generation Rules"}),"\n",(0,a.jsxs)(e.p,{children:["The time unit for the automatic partition table ",(0,a.jsx)(e.code,{children:"auto-partition.time-unit"})," can take values of HOUR, DAY, MONTH, QUARTER, or YEAR. Automatic partitioning will use the following format to create partitions."]}),"\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"Time Unit"}),(0,a.jsx)(e.th,{children:"Partition Format"}),(0,a.jsx)(e.th,{children:"Example"})]})}),(0,a.jsxs)(e.tbody,{children:[(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"HOUR"}),(0,a.jsx)(e.td,{children:"yyyyMMddHH"}),(0,a.jsx)(e.td,{children:"2024091922"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"DAY"}),(0,a.jsx)(e.td,{children:"yyyyMMdd"}),(0,a.jsx)(e.td,{children:"20240919"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"MONTH"}),(0,a.jsx)(e.td,{children:"yyyyMM"}),(0,a.jsx)(e.td,{children:"202409"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"QUARTER"}),(0,a.jsx)(e.td,{children:"yyyyQ"}),(0,a.jsx)(e.td,{children:"20241"})]}),(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"YEAR"}),(0,a.jsx)(e.td,{children:"yyyy"}),(0,a.jsx)(e.td,{children:"2024"})]})]})]}),"\n",(0,a.jsx)(e.h3,{id:"fluss-cluster-configuration",children:"Fluss Cluster Configuration"}),"\n",(0,a.jsx)(e.p,{children:"Below are the configuration items related to Fluss cluster and automatic partitioning."}),"\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"Option"}),(0,a.jsx)(e.th,{children:"Type"}),(0,a.jsx)(e.th,{children:"Default"}),(0,a.jsx)(e.th,{children:"Description"})]})}),(0,a.jsx)(e.tbody,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"auto-partition.check.interval"}),(0,a.jsx)(e.td,{children:"Duration"}),(0,a.jsx)(e.td,{children:"10 minutes"}),(0,a.jsx)(e.td,{children:"The interval of auto partition check. The time interval for automatic partition checking is set to 10 minutes by default, meaning that it checks the table partition status every 10 minutes to see if it meets the automatic partitioning criteria. If it does not meet the criteria, partitions will be automatically created or deleted."})]})})]}),"\n",(0,a.jsx)(e.h2,{id:"dynamic-partitioning",children:"Dynamic Partitioning"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Dynamic partitioning"})," is a feature that is enabled by default on client, allowing the client to automatically create partitions based on the data being written to the table. This feature is especially valuable when the set of partitions is not known in advance, eliminating the need for manual partition creation. It is also particularly useful when working with multi-field partitions, as auto-partitioning currently only supports single-field partitioning creation."]}),"\n",(0,a.jsxs)(e.p,{children:["Please note that the number of dynamically created partitions is also subject to the ",(0,a.jsx)(e.code,{children:"max.partition.num"})," and ",(0,a.jsx)(e.code,{children:"max.bucket.num"})," limit configured on the Fluss cluster."]}),"\n",(0,a.jsx)(e.h3,{id:"client-options",children:"Client Options"}),"\n",(0,a.jsxs)(e.table,{children:[(0,a.jsx)(e.thead,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.th,{children:"Option"}),(0,a.jsx)(e.th,{children:"Type"}),(0,a.jsx)(e.th,{children:"Required"}),(0,a.jsx)(e.th,{children:"Default"}),(0,a.jsx)(e.th,{children:"Description"})]})}),(0,a.jsx)(e.tbody,{children:(0,a.jsxs)(e.tr,{children:[(0,a.jsx)(e.td,{children:"client.writer.dynamic-create-partition.enabled"}),(0,a.jsx)(e.td,{children:"Boolean"}),(0,a.jsx)(e.td,{children:"no"}),(0,a.jsx)(e.td,{children:"true"}),(0,a.jsx)(e.td,{children:"Whether to enable dynamic partition creation for the client writer. When enabled, new partitions are automatically created if they don't already exist during data writes."})]})})]})]})}function h(t={}){const{wrapper:e}={...(0,r.R)(),...t.components};return e?(0,a.jsx)(e,{...t,children:(0,a.jsx)(c,{...t})}):c(t)}},8453:(t,e,i)=>{i.d(e,{R:()=>s,x:()=>o});var n=i(6540);const a={},r=n.createContext(a);function s(t){const e=n.useContext(r);return n.useMemo(function(){return"function"==typeof t?t(e):{...e,...t}},[e,t])}function o(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(a):t.components||a:s(t.components),n.createElement(r.Provider,{value:e},t.children)}}}]);