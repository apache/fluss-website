"use strict";(self.webpackChunkfluss_website=self.webpackChunkfluss_website||[]).push([[6586],{2248:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"security/overview","title":"Security Overview","description":"\x3c!--","source":"@site/versioned_docs/version-0.7/security/overview.md","sourceDirName":"security","slug":"/security/overview","permalink":"/docs/security/overview","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/fluss/edit/main/website/docs/security/overview.md","tags":[],"version":"0.7","sidebarPosition":1,"frontMatter":{"sidebar_label":"Security Overview","title":"Security Overview","sidebar_position":1},"sidebar":"docsSidebar","previous":{"title":"Racks","permalink":"/docs/maintenance/operations/racks"},"next":{"title":"Authentication","permalink":"/docs/security/authentication"}}');var s=n(4848),r=n(8453);const o={sidebar_label:"Security Overview",title:"Security Overview",sidebar_position:1},c="Security Overview",a={},l=[{value:"How Authentication Works in Fluss",id:"how-authentication-works-in-fluss",level:2},{value:"What is Authentication?",id:"what-is-authentication",level:3},{value:"Listener-Based Security Configuration",id:"listener-based-security-configuration",level:3},{value:"Server-Side Authentication Properties",id:"server-side-authentication-properties",level:3},{value:"Client-Side Authentication Properties",id:"client-side-authentication-properties",level:3},{value:"How Authorization Works in Fluss",id:"how-authorization-works-in-fluss",level:2},{value:"What is Authorization?",id:"what-is-authorization",level:3},{value:"Fluss Principal \u2013 The Bridge Between Authentication and Authorization",id:"fluss-principal--the-bridge-between-authentication-and-authorization",level:3},{value:"Enable Authorization and Assign Super Users",id:"enable-authorization-and-assign-super-users",level:3},{value:"Security Workflow When Client Established a Connection",id:"security-workflow-when-client-established-a-connection",level:2}];function d(e){const i={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"security-overview",children:"Security Overview"})}),"\n",(0,s.jsx)(i.p,{children:"Fluss provides a comprehensive security model based on two core components:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:(0,s.jsx)(i.a,{href:"/docs/security/authentication",children:"Authentication"})}),": is the process of verifying the identity of the client"]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.strong,{children:(0,s.jsx)(i.a,{href:"/docs/security/authorization",children:"Authorization"})}),": controls which resources the identity can access and which operations it can perform"]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"By default, Fluss does not enable either feature, meaning all clients can access the system without verification or restrictions. While this is convenient for development and testing, it is not suitable for production environments due to potential security risks."}),"\n",(0,s.jsxs)(i.p,{children:["Fluss supports ",(0,s.jsx)(i.strong,{children:"pluggable mechanisms"})," for both authentication and authorization, allowing users to customize security policies based on their needs."]}),"\n",(0,s.jsx)(i.h2,{id:"how-authentication-works-in-fluss",children:"How Authentication Works in Fluss"}),"\n",(0,s.jsx)(i.h3,{id:"what-is-authentication",children:"What is Authentication?"}),"\n",(0,s.jsx)(i.p,{children:"Authentication is the process of identifying who is trying to access the system."}),"\n",(0,s.jsx)(i.p,{children:"When a client (like an application or user) connects to Fluss, it must prove its identity using one of the supported methods. Fluss currently supports:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"PLAINTEXT"}),": No authentication (default). Suitable only for internal or development use."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:"SASL"}),": This mechanism is based on SASL (Simple Authentication and Security Layer) authentication. Currently, only SASL/PLAIN is supported, which involves authentication using a username and password."]}),"\n",(0,s.jsx)(i.li,{children:"Custom Plugins: Extendable via plugins for enterprise or third-party integrations."}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"listener-based-security-configuration",children:"Listener-Based Security Configuration"}),"\n",(0,s.jsx)(i.p,{children:"In Fluss, a listener refers to a network endpoint that the server listens on for incoming connections from clients or internal services. Each listener is associated with a name (e.g., CLIENT, INTERNAL) and an address/port binding."}),"\n",(0,s.jsx)(i.p,{children:"Listeners allow Fluss server (TabletServer and CoordinatorServer) to support multiple connection endpoints with different purposes and security requirements: one listener may be used for internal communication between servers while others may be exposed to external clients and require different authentication protocols.\nThis flexibility enables operators to apply different security protocols per listener, ensuring appropriate protection levels based on who or what is connecting."}),"\n",(0,s.jsx)(i.p,{children:"Server side listener configurations:"}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Option"}),(0,s.jsx)(i.th,{children:"Type"}),(0,s.jsx)(i.th,{children:"Default Value"}),(0,s.jsx)(i.th,{children:"Description"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"bind.listeners"}),(0,s.jsx)(i.td,{children:"String"}),(0,s.jsx)(i.td,{children:"FLUSS://localhost:9123"}),(0,s.jsxs)(i.td,{children:["The network address and port to which the server binds for accepting connections. This defines the interface and port where the server will listen for incoming requests. The format is ",(0,s.jsx)(i.code,{children:"listener_name://host:port"}),", and multiple addresses can be specified, separated by commas. Use ",(0,s.jsx)(i.code,{children:"0.0.0.0"})," for the ",(0,s.jsx)(i.code,{children:"host"})," to bind to all available interfaces which is dangerous on production and not suggested for production usage. The ",(0,s.jsx)(i.code,{children:"listener_name"})," serves as an identifier for the address in the configuration. For example, ",(0,s.jsx)(i.code,{children:"internal.listener.name"})," specifies the address used for internal server communication. If multiple addresses are configured, ensure that the ",(0,s.jsx)(i.code,{children:"listener_name"})," values are unique."]})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"advertised.listeners"}),(0,s.jsx)(i.td,{children:"(none)"}),(0,s.jsx)(i.td,{children:"String"}),(0,s.jsxs)(i.td,{children:["The externally advertised address and port for client connections. Required in distributed environments when the bind address is not publicly reachable. Format matches ",(0,s.jsx)(i.code,{children:"bind.listeners"})," (listener_name://host",":port","). Defaults to the value of ",(0,s.jsx)(i.code,{children:"bind.listeners"})," if not explicitly configured."]})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"internal.listener.name"}),(0,s.jsx)(i.td,{children:"FLUSS"}),(0,s.jsx)(i.td,{children:"String"}),(0,s.jsx)(i.td,{children:"The listener name used for internal server communication."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"security.protocol.map"}),(0,s.jsx)(i.td,{children:"Map"}),(0,s.jsx)(i.td,{children:"(none)"}),(0,s.jsxs)(i.td,{children:["A map defining the authentication protocol for each listener. The format is ",(0,s.jsx)(i.code,{children:"listenerName1:protocol1,listenerName2:protocol2"}),", e.g.,",(0,s.jsx)(i.code,{children:"CLIENT:SASL, INTERNAL:PLAINTEXT"}),".A map defining the authentication protocol for each listener. The format is ",(0,s.jsx)(i.code,{children:"listenerName1:protocol1,listenerName2:protocol2"}),", e.g., ",(0,s.jsx)(i.code,{children:"INTERNAL:PLAINTEXT,CLIENT:GSSAPI"}),". Each listener can be associated with a specific authentication protocol. Listeners not included in the map will use PLAINTEXT by default, which does not require authentication. Currently, only PLAINTEXT and SASL/PLAIN are supported."]})]})]})]}),"\n",(0,s.jsx)(i.p,{children:"Here is an example server side configuration:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-yaml",metastring:'title="conf/server.yaml"',children:"bind.listeners: INTERNAL://localhost:9092, CLIENT://localhost:9093\nadvertised.listeners: CLIENT://node1:9093\nsecurity.protocol.map: CLIENT:SASL, INTERNAL:PLAINTEXT\ninternal.listener.name: INTERNAL\n"})}),"\n",(0,s.jsx)(i.p,{children:"In this example:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["Port ",(0,s.jsx)(i.strong,{children:"9092 (INTERNAL)"})," is used for internal communication and uses PLAINTEXT (no authentication required)."]}),"\n",(0,s.jsxs)(i.li,{children:["Port ",(0,s.jsx)(i.strong,{children:"9093 (CLIENT)"})," requires SASL/PLAIN authentication for secure client access and exposes the external address ",(0,s.jsx)(i.code,{children:"node1"})," for external connectivity."]}),"\n"]}),"\n",(0,s.jsxs)(i.p,{children:["Each connection must use the protocol defined in ",(0,s.jsx)(i.code,{children:"security.protocol.map"}),". If a client attempts to connect using an incorrect protocol, the authentication will fail."]}),"\n",(0,s.jsx)(i.h3,{id:"server-side-authentication-properties",children:"Server-Side Authentication Properties"}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Property"}),(0,s.jsx)(i.th,{children:"Description"}),(0,s.jsx)(i.th,{children:"Default Value"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"security.protocol.map"}),(0,s.jsxs)(i.td,{children:["A map defining the authentication protocol for each listener. The format is ",(0,s.jsx)(i.code,{children:"listenerName1:protocol1,listenerName2:protocol2"}),", e.g.,",(0,s.jsx)(i.code,{children:"CLIENT:SASL, INTERNAL:PLAINTEXT"}),"."]}),(0,s.jsx)(i.td,{children:"(none)"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"security.{protocol}.*"})}),(0,s.jsx)(i.td,{children:"Protocol-specific configuration properties. For example, security.sasl.jaas.config for SASL authentication settings."}),(0,s.jsx)(i.td,{children:"(none)"})]})]})]}),"\n",(0,s.jsx)(i.h3,{id:"client-side-authentication-properties",children:"Client-Side Authentication Properties"}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Property"}),(0,s.jsx)(i.th,{children:"Description"}),(0,s.jsx)(i.th,{children:"Default Value"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"client.security.protocol"}),(0,s.jsxs)(i.td,{children:["The security protocol used to communicate with brokers. Currently, only ",(0,s.jsx)(i.code,{children:"PLAINTEXT"})," and ",(0,s.jsx)(i.code,{children:"SASL"})," are supported, the configuration value is case insensitive."]}),(0,s.jsx)(i.td,{children:"PLAINTEXT"})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:(0,s.jsx)(i.code,{children:"client.security.{protocol}.*"})}),(0,s.jsxs)(i.td,{children:["Client-side configuration properties for a specific authentication protocol. E.g., ",(0,s.jsx)(i.code,{children:"client.security.sasl.jaas.config"}),"."]}),(0,s.jsx)(i.td,{children:"(none)"})]})]})]}),"\n",(0,s.jsx)(i.h2,{id:"how-authorization-works-in-fluss",children:"How Authorization Works in Fluss"}),"\n",(0,s.jsx)(i.h3,{id:"what-is-authorization",children:"What is Authorization?"}),"\n",(0,s.jsxs)(i.p,{children:["Authorization determines ",(0,s.jsx)(i.strong,{children:"what an authenticated user is allowed to do"}),". Even after successful authentication, a user may not have permission to perform certain operations like reading or writing data."]}),"\n",(0,s.jsxs)(i.p,{children:["Fluss uses ",(0,s.jsx)(i.strong,{children:"Access Control Lists (ACLs)"})," to define permissions for specific users or roles. These rules can be set at different levels such as tables, databases, or clusters."]}),"\n",(0,s.jsx)(i.p,{children:"For example:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["User ",(0,s.jsx)(i.code,{children:"admin"})," may have full read/write access to all tables."]}),"\n",(0,s.jsxs)(i.li,{children:["User ",(0,s.jsx)(i.code,{children:"guest"})," might only be allowed to consume messages from a specific table."]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"fluss-principal--the-bridge-between-authentication-and-authorization",children:"Fluss Principal \u2013 The Bridge Between Authentication and Authorization"}),"\n",(0,s.jsxs)(i.p,{children:["Once a client successfully authenticates, Fluss creates a ",(0,s.jsx)(i.strong,{children:"Fluss Principal"}),", which represents the authenticated identity. This  ",(0,s.jsx)(i.strong,{children:"Fluss Principal"})," is used throughout the system during authorization checks."]}),"\n",(0,s.jsx)(i.p,{children:'The principal type indicates the category of the principal (e. g., "User", "Group", "Role"), while the name identifies the specific entity within that category. By default, the simple authorizer uses "User" as the principal type, but custom authorizers can extend this to support role-based or group-based access control lists (ACLs).\nExample usage:'}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:'new FlussPrincipal("admin", "User")'})," \u2013 A standard user principal."]}),"\n",(0,s.jsxs)(i.li,{children:[(0,s.jsx)(i.code,{children:'new FlussPrincipal("admins", "Group")'})," \u2013 A group-based principal for authorization."]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"enable-authorization-and-assign-super-users",children:"Enable Authorization and Assign Super Users"}),"\n",(0,s.jsx)(i.p,{children:"Fluss provides a pluggable authorization framework that uses Access Control Lists (ACLs) to determine whether a given FlussPrincipal is allowed to perform an operation on a specific resource.To enable authorization, you need to configure the following properties:"}),"\n",(0,s.jsxs)(i.table,{children:[(0,s.jsx)(i.thead,{children:(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.th,{children:"Option"}),(0,s.jsx)(i.th,{children:"Type"}),(0,s.jsx)(i.th,{children:"Default Value"}),(0,s.jsx)(i.th,{children:"Description"})]})}),(0,s.jsxs)(i.tbody,{children:[(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"authorizer.enabled"}),(0,s.jsx)(i.td,{children:"Boolean"}),(0,s.jsx)(i.td,{children:"false"}),(0,s.jsx)(i.td,{children:"Specifies whether to enable the authorization feature."})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"authorizer.type"}),(0,s.jsx)(i.td,{children:"String"}),(0,s.jsx)(i.td,{children:"default"}),(0,s.jsxs)(i.td,{children:["Specifies the type of authorizer to be used for access control. This value corresponds to the identifier of the authorization plugin. The default value is ",(0,s.jsx)(i.code,{children:"default"}),", which indicates the built-in authorizer implementation. Custom authorizers can be implemented by providing a matching plugin identifier."]})]}),(0,s.jsxs)(i.tr,{children:[(0,s.jsx)(i.td,{children:"super.users"}),(0,s.jsx)(i.td,{children:"String"}),(0,s.jsx)(i.td,{children:"(None)"}),(0,s.jsxs)(i.td,{children:["A semicolon-separated list of superusers who have unrestricted access to all operations and resources. Note that the delimiter is semicolon since SSL user names may contain comma, and each super user should be specified in the format ",(0,s.jsx)(i.code,{children:"principal_type:principal_name"}),", e.g., ",(0,s.jsx)(i.code,{children:"User:admin;User:bob"}),". This configuration is critical for defining administrative privileges in the system."]})]})]})]}),"\n",(0,s.jsx)(i.h2,{id:"security-workflow-when-client-established-a-connection",children:"Security Workflow When Client Established a Connection"}),"\n",(0,s.jsx)(i.p,{children:"This section walks through the complete security workflow in Fluss from the moment a client establishes a connection, covering both authentication and authorization."}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsx)(i.p,{children:"Client establishes a connection with the server"}),"\n",(0,s.jsxs)(i.p,{children:["A client (such as a Flink job, producer, or consumer) initiates a connection to a Fluss server endpoint \u2014 known as a listener. Each listener has a name (e.g., CLIENT, INTERNAL) and is associated with a specific ",(0,s.jsx)(i.code,{children:"host:port"})," binding."]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsx)(i.p,{children:"Authentication protocol is selected"}),"\n",(0,s.jsxs)(i.p,{children:["Based on the configuration in ",(0,s.jsx)(i.code,{children:"security.protocol.map"}),", Fluss selects the appropriate authentication protocol for the listener the client is connecting to.\nFor example:"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-yaml",children:"security.protocol.map: CLIENT:SASL, INTERNAL:PLAINTEXT\n"})}),"\n",(0,s.jsxs)(i.p,{children:["If the client connects to the ",(0,s.jsx)(i.code,{children:"CLIENT"})," listener, SASL authentication will be used."]}),"\n",(0,s.jsxs)(i.ol,{start:"3",children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsx)(i.p,{children:"Authentication process"}),"\n",(0,s.jsx)(i.p,{children:"The client presents its credentials using the selected authentication method. For SASL/PLAIN, this typically includes a username and password."}),"\n",(0,s.jsx)(i.p,{children:"If the credentials are valid and the authentication is successful, and the client is allowed to proceed with further operations. Otherwise, the connection is rejected, and an authentication error is returned."}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsx)(i.p,{children:"Fluss Principal Is created"}),"\n",(0,s.jsx)(i.p,{children:"Upon successful authentication, Fluss creates a FlussPrincipal, representing the identity of the authenticated user"}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsx)(i.p,{children:"Authorization check occur"}),"\n",(0,s.jsx)(i.p,{children:"Before allowing any operation (like producing or consuming data), Fluss checks whether the FlussPrincipal has permission to perform that action based on configured ACL rules."}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsx)(i.p,{children:"Response to the client"}),"\n",(0,s.jsx)(i.p,{children:"If the authorization check passes, the client can proceed with its intended operation (e.g., reading or writing data). If it fails, an authorization error is returned."}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>o,x:()=>c});var t=n(6540);const s={},r=t.createContext(s);function o(e){const i=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function c(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:i},e.children)}}}]);