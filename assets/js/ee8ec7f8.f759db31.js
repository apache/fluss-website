"use strict";(self.webpackChunkfluss_website=self.webpackChunkfluss_website||[]).push([[1852],{3182:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"table-design/table-types/pk-table","title":"PrimaryKey Table","description":"Basic Concept","source":"@site/versioned_docs/version-0.5/table-design/table-types/pk-table.md","sourceDirName":"table-design/table-types","slug":"/table-design/table-types/pk-table","permalink":"/docs/0.5/table-design/table-types/pk-table","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/fluss/edit/main/website/docs/table-design/table-types/pk-table.md","tags":[],"version":"0.5","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Log Table","permalink":"/docs/0.5/table-design/table-types/log-table"},"next":{"title":"Bucketing","permalink":"/docs/0.5/table-design/data-distribution/bucketing"}}');var a=n(4848),i=n(8453);const l={sidebar_position:2},r="PrimaryKey Table",d={},c=[{value:"Basic Concept",id:"basic-concept",level:2},{value:"Bucket Assigning",id:"bucket-assigning",level:2},{value:"Partial Update",id:"partial-update",level:2},{value:"Data Queries",id:"data-queries",level:2},{value:"Changelog Generation",id:"changelog-generation",level:2},{value:"Data Consumption",id:"data-consumption",level:2}];function o(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"primarykey-table",children:"PrimaryKey Table"})}),"\n",(0,a.jsx)(t.h2,{id:"basic-concept",children:"Basic Concept"}),"\n",(0,a.jsxs)(t.p,{children:["PrimaryKey Table in Fluss ensure the uniqueness of the specified primary key and supports ",(0,a.jsx)(t.code,{children:"INSERT"}),", ",(0,a.jsx)(t.code,{children:"UPDATE"}),", and ",(0,a.jsx)(t.code,{children:"DELETE"})," operations."]}),"\n",(0,a.jsxs)(t.p,{children:["A PrimaryKey Table is created by specifying a ",(0,a.jsx)(t.code,{children:"PRIMARY KEY"})," clause in the ",(0,a.jsx)(t.code,{children:"CREATE TABLE"})," statement. For example, the following Flink SQL statement creates a PrimaryKey Table with ",(0,a.jsx)(t.code,{children:"shop_id"})," and ",(0,a.jsx)(t.code,{children:"user_id"})," as the primary key and distributes the data into 4 buckets:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",metastring:'title="Flink SQL"',children:"CREATE TABLE pk_table (\n  shop_id BIGINT,\n  user_id BIGINT,\n  num_orders INT,\n  total_amount INT,\n  PRIMARY KEY (shop_id, user_id) NOT ENFORCED\n) WITH (\n  'bucket.num' = '4'\n);\n"})}),"\n",(0,a.jsx)(t.p,{children:"In Fluss primary key table, each row of data has a unique primary key.\nIf multiple entries with the same primary key are written to the Fluss primary key table, only the last entry will be retained."}),"\n",(0,a.jsxs)(t.p,{children:["For ",(0,a.jsx)(t.a,{href:"/docs/0.5/table-design/data-distribution/partitioning",children:"Partitioned PrimaryKey Table"}),", the primary key must contain the partition key."]}),"\n",(0,a.jsx)(t.h2,{id:"bucket-assigning",children:"Bucket Assigning"}),"\n",(0,a.jsx)(t.p,{children:"For primary key tables, Fluss always determines which bucket the data belongs to based on the hash value of the primary key for each record.\nData with the same hash value will be distributed to the same bucket."}),"\n",(0,a.jsx)(t.h2,{id:"partial-update",children:"Partial Update"}),"\n",(0,a.jsx)(t.p,{children:"For primary key tables, Fluss supports partial column updates, allowing you to write only a subset of columns to incrementally update the data and ultimately achieve complete data. Note that the columns being written must include the primary key column."}),"\n",(0,a.jsx)(t.p,{children:"For example, consider the following Fluss primary key table:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",metastring:'title="Flink SQL"',children:"CREATE TABLE T (\n  k INT,\n  v1 DOUBLE,\n  v2 STRING,\n  PRIMARY KEY (k) NOT ENFORCED\n);\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Assuming that at the beginning, only the ",(0,a.jsx)(t.code,{children:"k"})," and ",(0,a.jsx)(t.code,{children:"v1"})," columns are written with the data ",(0,a.jsx)(t.code,{children:"+I(1, 2.0)"}),", ",(0,a.jsx)(t.code,{children:"+I(2, 3.0)"}),", the data in T is as follows:"]}),"\n",(0,a.jsxs)(t.table,{children:[(0,a.jsx)(t.thead,{children:(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.th,{children:"k"}),(0,a.jsx)(t.th,{children:"v1"}),(0,a.jsx)(t.th,{children:"v2"})]})}),(0,a.jsxs)(t.tbody,{children:[(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"1"}),(0,a.jsx)(t.td,{children:"2.0"}),(0,a.jsx)(t.td,{children:"null"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"2"}),(0,a.jsx)(t.td,{children:"3.0"}),(0,a.jsx)(t.td,{children:"null"})]})]})]}),"\n",(0,a.jsxs)(t.p,{children:["Then write to the ",(0,a.jsx)(t.code,{children:"k"})," and ",(0,a.jsx)(t.code,{children:"v2"})," columns with the data ",(0,a.jsx)(t.code,{children:"+I(1, 't1')"}),", ",(0,a.jsx)(t.code,{children:"+I(2, 't2')"}),", resulting in the data in T as follows:"]}),"\n",(0,a.jsxs)(t.table,{children:[(0,a.jsx)(t.thead,{children:(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.th,{children:"k"}),(0,a.jsx)(t.th,{children:"v1"}),(0,a.jsx)(t.th,{children:"v2"})]})}),(0,a.jsxs)(t.tbody,{children:[(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"1"}),(0,a.jsx)(t.td,{children:"2.0"}),(0,a.jsx)(t.td,{children:"t1"})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{children:"2"}),(0,a.jsx)(t.td,{children:"3.0"}),(0,a.jsx)(t.td,{children:"t2"})]})]})]}),"\n",(0,a.jsx)(t.h2,{id:"data-queries",children:"Data Queries"}),"\n",(0,a.jsxs)(t.p,{children:["For primary key tables, Fluss supports querying data directly based on the key. Please refer to the ",(0,a.jsx)(t.a,{href:"/docs/0.5/engine-flink/reads",children:"Flink Reads"})," for detailed instructions."]}),"\n",(0,a.jsx)(t.h2,{id:"changelog-generation",children:"Changelog Generation"}),"\n",(0,a.jsx)(t.p,{children:"Fluss will capture the changes when inserting, updating, deleting records on the primary-key table, which is known as the changelog. Downstream consumers can directly consume the changelog to obtain the changes in the table. For example, consider the following primary key table in Fluss:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-sql",metastring:'title="Flink SQL"',children:"CREATE TABLE T (\n  k INT,\n  v1 DOUBLE,\n  v2 STRING,\n  PRIMARY KEY (k) NOT ENFORCED\n);\n"})}),"\n",(0,a.jsxs)(t.p,{children:["If the data written to the primary-key table is sequentially ",(0,a.jsx)(t.code,{children:"+I(1, 2.0, 'apple')"}),", ",(0,a.jsx)(t.code,{children:"+I(1, 4.0, 'banana')"}),", ",(0,a.jsx)(t.code,{children:"-D(1, 4.0, 'banana')"}),", then the following change data will be generated."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-text",children:"+I(1, 2.0, 'apple')\n-U(1, 2.0, 'apple')\n+U(1, 4.0, 'banana')\n-D(1, 4.0, 'banana')\n"})}),"\n",(0,a.jsx)(t.h2,{id:"data-consumption",children:"Data Consumption"}),"\n",(0,a.jsx)(t.p,{children:"For a primary key table, the default consumption method is a full snapshot followed by incremental data. First, the snapshot data of the table is consumed, followed by the binlog data of the table."}),"\n",(0,a.jsxs)(t.p,{children:["It is also possible to only consume the binlog data of the table. For more details, please refer to the ",(0,a.jsx)(t.a,{href:"/docs/0.5/engine-flink/reads",children:"Flink Reads"})]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(o,{...e})}):o(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>l,x:()=>r});var s=n(6540);const a={},i=s.createContext(a);function l(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:l(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);