"use strict";(self.webpackChunkfluss_website=self.webpackChunkfluss_website||[]).push([[7386],{8062:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>i,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"maintenance/tiered-storage/remote-storage","title":"Remote Storage","description":"Remote storage usually means a cost-efficient and fault-tolerant storage comparing to local disk, such as S3, HDFS, OSS.","source":"@site/versioned_docs/version-0.5/maintenance/tiered-storage/remote-storage.md","sourceDirName":"maintenance/tiered-storage","slug":"/maintenance/tiered-storage/remote-storage","permalink":"/docs/0.5/maintenance/tiered-storage/remote-storage","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/fluss/edit/main/website/docs/maintenance/tiered-storage/remote-storage.md","tags":[],"version":"0.5","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Overview","permalink":"/docs/0.5/maintenance/tiered-storage/overview"},"next":{"title":"Lakehouse Storage","permalink":"/docs/0.5/maintenance/tiered-storage/lakehouse-storage"}}');var r=o(4848),n=o(8453);const a={sidebar_position:2},l="Remote Storage",i={},d=[{value:"Remote Log",id:"remote-log",level:2},{value:"Cluster configurations about remote log",id:"cluster-configurations-about-remote-log",level:3},{value:"Table configurations about remote log",id:"table-configurations-about-remote-log",level:3},{value:"Remote snapshot of primary key table",id:"remote-snapshot-of-primary-key-table",level:2},{value:"Cluster configurations about remote snapshot",id:"cluster-configurations-about-remote-snapshot",level:3}];function c(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,n.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"remote-storage",children:"Remote Storage"})}),"\n",(0,r.jsxs)(t.p,{children:["Remote storage usually means a cost-efficient and fault-tolerant storage comparing to local disk, such as S3, HDFS, OSS.\nSee more detail about how to configure remote storage in documentation of ",(0,r.jsx)(t.a,{href:"/docs/0.5/maintenance/filesystems/overview",children:"filesystems"}),"."]}),"\n",(0,r.jsx)(t.p,{children:"For log table, Fluss will use remote storage to store the tiered log segments of data. For primary key table, Fluss will use remote storage to store the snapshot as well as the tiered log segments for change log."}),"\n",(0,r.jsx)(t.h2,{id:"remote-log",children:"Remote Log"}),"\n",(0,r.jsx)(t.p,{children:"As a streaming storage, Fluss data is mostly consumed in a streaming fashion using tail reads. To achieve low\nlatency for tail reads, Fluss will store recent data in local disk. But for older data, to reduce local disk cost,\nFluss will move data from local to remote storage, such as S3, HDFS or OSS asynchronously."}),"\n",(0,r.jsx)(t.h3,{id:"cluster-configurations-about-remote-log",children:"Cluster configurations about remote log"}),"\n",(0,r.jsxs)(t.p,{children:["By default, Fluss will copy local log segments to remote storage in every 1 minute. The interval is controlled by configuration ",(0,r.jsx)(t.code,{children:"remote.log.task-interval-duration"}),".\nIf you don't want to copy log segments to remote storage, you can set ",(0,r.jsx)(t.code,{children:"remote.log.task-interval-duration"})," to 0."]}),"\n",(0,r.jsx)(t.p,{children:"Below is the list for all configurations to control the log segments tiered behavior in cluster level:"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Configuration"}),(0,r.jsx)(t.th,{children:"type"}),(0,r.jsx)(t.th,{children:"Default"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"remote.log.task-interval-duration"}),(0,r.jsx)(t.td,{children:"Duration"}),(0,r.jsx)(t.td,{children:"1min"}),(0,r.jsx)(t.td,{children:"Interval at which remote log manager runs the scheduled tasks like copy segments, clean up remote log segments, delete local log segments etc. If the value is set to 0s, it means that the remote log storage is disabled."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"remote.log.index-file-cache-size"}),(0,r.jsx)(t.td,{children:"MemorySize"}),(0,r.jsx)(t.td,{children:"1gb"}),(0,r.jsx)(t.td,{children:"The total size of the space allocated to store index files fetched from remote storage in the local storage."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"remote.log-manager.thread-pool-size"}),(0,r.jsx)(t.td,{children:"Integer"}),(0,r.jsx)(t.td,{children:"4"}),(0,r.jsx)(t.td,{children:"Size of the thread pool used in scheduling tasks to copy segments, fetch remote log indexes and clean up remote log segments."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"remote.log.data-transfer-thread-num"}),(0,r.jsx)(t.td,{children:"Integer"}),(0,r.jsx)(t.td,{children:"4"}),(0,r.jsx)(t.td,{children:"The number of threads the server uses to transfer (download and upload) remote log file can be  data file, index file and remote log metadata file."})]})]})]}),"\n",(0,r.jsx)(t.h3,{id:"table-configurations-about-remote-log",children:"Table configurations about remote log"}),"\n",(0,r.jsxs)(t.p,{children:["When local log segments are copied to remote storage, the local log segments will be deleted to reduce local disk cost.\nBut sometimes, we want to keep the several latest log segments retain in local, although they have been coped to remote storage for better read performance.\nYou can control how many log segments to retain in local by setting the configuration ",(0,r.jsx)(t.code,{children:"table.log.tiered.local-segments"}),"(default is 2) per table."]}),"\n",(0,r.jsx)(t.h2,{id:"remote-snapshot-of-primary-key-table",children:"Remote snapshot of primary key table"}),"\n",(0,r.jsx)(t.p,{children:"In Fluss, one primary key table is distributed to multiple buckets. For each bucket of primary key table, Fluss will only always keep one replica in local disk without any follower replicas."}),"\n",(0,r.jsx)(t.p,{children:"So, for fault tolerance of local disk fail forever, Fluss will do snapshots to the replicas of primary key table periodically and upload the snapshots to remote storage.\nThe snapshot will keep a log offset representing the next unread change log while doing the snapshot. Then, when the machine holding the replica fails, Fluss can recover the replica in other live machines by downloading the snapshot from remote storage and apply the change log\nsince last snapshot."}),"\n",(0,r.jsx)(t.p,{children:"What's more, with the snapshot and the consistent log offset, Fluss client can seamlessly switch from full reading phase(reading snapshot) to the incremental\nphase (subscribe change log from the consistent log offset) without any data duplication or loss."}),"\n",(0,r.jsx)(t.h3,{id:"cluster-configurations-about-remote-snapshot",children:"Cluster configurations about remote snapshot"}),"\n",(0,r.jsx)(t.p,{children:"Below is the list for all configurations to control the snapshot behavior in cluster level:"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Configuration"}),(0,r.jsx)(t.th,{children:"type"}),(0,r.jsx)(t.th,{children:"Default"}),(0,r.jsx)(t.th,{children:"Description"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"kv.snapshot.interval"}),(0,r.jsx)(t.td,{children:"Duration"}),(0,r.jsx)(t.td,{children:"10min"}),(0,r.jsx)(t.td,{children:"The interval to perform periodic snapshot for kv data."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"kv.snapshot.scheduler-thread-num"}),(0,r.jsx)(t.td,{children:"Integer"}),(0,r.jsx)(t.td,{children:"1"}),(0,r.jsx)(t.td,{children:"The number of threads that the server uses to schedule snapshot kv data for all the replicas in the server."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"kv.snapshot.transfer-thread-num"}),(0,r.jsx)(t.td,{children:"Integer"}),(0,r.jsx)(t.td,{children:"4"}),(0,r.jsx)(t.td,{children:"The number of threads the server uses to transfer (download and upload) kv snapshot files."})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"kv.snapshot.num-retained"}),(0,r.jsx)(t.td,{children:"Integer"}),(0,r.jsx)(t.td,{children:"1"}),(0,r.jsx)(t.td,{children:"The maximum number of completed snapshots to retain. It's recommended to set it to a larger value to avoid the case that server delete the snapshot while the client is still reading the snapshot."})]})]})]})]})}function h(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453:(e,t,o)=>{o.d(t,{R:()=>a,x:()=>l});var s=o(6540);const r={},n=s.createContext(r);function a(e){const t=s.useContext(n);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(n.Provider,{value:t},e.children)}}}]);