<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.8.1">
<title data-rh="true">Introducing Fluss: Streaming Storage for Real-Time Analytics | Fluss</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://fluss.apache.org/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://fluss.apache.org/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://fluss.apache.org/blog/fluss-intro/"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="Introducing Fluss: Streaming Storage for Real-Time Analytics | Fluss"><meta data-rh="true" name="description" content="&lt;!--"><meta data-rh="true" property="og:description" content="&lt;!--"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2024-12-12T00:00:00.000Z"><meta data-rh="true" property="article:author" content="https://github.com/wuchong"><link data-rh="true" rel="icon" href="/img/logo/fluss_favicon.svg"><link data-rh="true" rel="canonical" href="https://fluss.apache.org/blog/fluss-intro/"><link data-rh="true" rel="alternate" href="https://fluss.apache.org/blog/fluss-intro/" hreflang="en"><link data-rh="true" rel="alternate" href="https://fluss.apache.org/blog/fluss-intro/" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://D8RXQUTC99-dsn.algolia.net" crossorigin="anonymous"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","@id":"https://fluss.apache.org/blog/fluss-intro","mainEntityOfPage":"https://fluss.apache.org/blog/fluss-intro","url":"https://fluss.apache.org/blog/fluss-intro","headline":"Introducing Fluss: Streaming Storage for Real-Time Analytics","name":"Introducing Fluss: Streaming Storage for Real-Time Analytics","description":"<!--","datePublished":"2024-12-12T00:00:00.000Z","author":{"@type":"Person","name":"Jark Wu","description":"Creator of Fluss project","url":"https://github.com/wuchong","image":"https://github.com/wuchong.png"},"keywords":[],"isPartOf":{"@type":"Blog","@id":"https://fluss.apache.org/blog","name":"Blog"}}</script><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="Fluss RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="Fluss Atom Feed">




<link rel="search" type="application/opensearchdescription+xml" title="Fluss" href="/opensearch.xml">

<link rel="icon" href="/img/logo.svg">
<link rel="manifest" href="/manifest.json">
<meta name="theme-color" content="#0071e3"><link rel="stylesheet" href="/assets/css/styles.3ca55d09.css">
<script src="/assets/js/runtime~main.264c6f6f.js" defer="defer"></script>
<script src="/assets/js/main.a06cb6b9.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t="light";var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",e||t),document.documentElement.setAttribute("data-theme-choice",e||t)}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo/svg/colored_logo.svg" alt="Fluss" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo/svg/colored_logo.svg" alt="Fluss" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate"></b></a><a class="navbar__item navbar__link" href="/docs/intro/">Docs</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog/">Blog</a><a class="navbar__item navbar__link" href="/community/welcome/">Community</a><a class="navbar__item navbar__link" href="/roadmap/">Roadmap</a><a class="navbar__item navbar__link" href="/downloads/">Downloads</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://github.com/apache/fluss" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-github-link" aria-label="GitHub repository"></a><div class="navbarSearchContainer_Bca1"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search (Command+K)"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20" aria-hidden="true"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_pO2u margin-bottom--md">All our posts</div><div role="group"><h3 class="yearGroupHeading_rMGB">2025</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/releases/0.7/">Announcing Fluss 0.7</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/partial-updates/">Understanding Partial Updates</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/unveil-fluss-logo/">The Story of Fluss Logo</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/releases/0.6/">Announcing Fluss 0.6</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/unified-streaming-lakehouse/">Toward Streaming Lakehouse</a></li></ul></div><div role="group"><h3 class="yearGroupHeading_rMGB">2024</h3><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/blog/fluss-intro/">Introducing Fluss</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/why-fluss/">Why Fluss? Top 4 Challenges of Kafka</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/fluss-open-source/">Fluss is Now Open Source</a></li></ul></div></nav></aside><main class="col col--7"><article class=""><header><h1 class="title_f1Hy">Introducing Fluss: Streaming Storage for Real-Time Analytics</h1><div class="container_mt6G margin-vert--md"><time datetime="2024-12-12T00:00:00.000Z">December 12, 2024</time></div><div class="margin-top--md margin-bottom--sm row"><div class="col col--12 authorCol_Hf19"><div class="avatar margin-bottom--sm"><a href="https://github.com/wuchong" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo authorImage_XqGP" src="https://github.com/wuchong.png" alt="Jark Wu"></a><div class="avatar__intro authorDetails_lV9A"><div class="avatar__name"><a href="https://github.com/wuchong" target="_blank" rel="noopener noreferrer"><span class="authorName_yefp">Jark Wu</span></a></div><small class="authorTitle_nd0D" title="Creator of Fluss project">Creator of Fluss project</small><div class="authorSocials_rSDt"></div></div></div></div></div></header><div id="__blog-post-container" class="markdown"><p>We have discussed the challenges of using Kafka for real-time analytics in our previous <a href="/blog/why-fluss/">blog post</a>.
Today, we are excited to introduce Fluss, a cutting-edge streaming storage system designed to power real-time analytics.
We are going to explore Fluss&#x27;s architecture, design principles, key features, and how it addresses the challenges of using Kafka for real-time analytics.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="key-features-of-fluss">Key Features of Fluss<a href="#key-features-of-fluss" class="hash-link" aria-label="Direct link to Key Features of Fluss" title="Direct link to Key Features of Fluss">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="columnar-stream">Columnar Stream<a href="#columnar-stream" class="hash-link" aria-label="Direct link to Columnar Stream" title="Direct link to Columnar Stream">​</a></h3>
<p><img decoding="async" loading="lazy" alt="FF Announcement" src="/assets/images/img1-591c05a64a0e27a33a3ce5776391d92d.jpg" width="3634" height="1188" class="img_ev3q">
Fluss is, as anticipated, a columnar-based streaming storage, leveraging the <a href="https://arrow.apache.org/docs/python/ipc.html" target="_blank" rel="noopener noreferrer">Apache Arrow IPC Streaming Format</a> for its underlying file storage.
This enables Fluss to achieve highly efficient column pruning while maintaining millisecond-level streaming reads and writes capabilities.</p>
<p>The performance benefits of Fluss are evident in its benchmarks against Kafka. In the comparison, the horizontal axis represents the number of columns read, while the vertical axis shows the read throughput. The results clearly demonstrate that Fluss&#x27;s read performance scales proportionally with the reduction in columns read. For example, when the number of columns is reduced by 90%, Fluss achieves a 10x increase in read throughput.</p>
<p>A key advantage of Fluss is that column pruning is performed server-side and only the needed column data will be transferred to client-side. This architectural design not only enhances performance but also reduces network costs and resource consumption, making Fluss a highly efficient solution for real-time streaming analytics.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="real-time-updates-and-changelog">Real-Time Updates and Changelog<a href="#real-time-updates-and-changelog" class="hash-link" aria-label="Direct link to Real-Time Updates and Changelog" title="Direct link to Real-Time Updates and Changelog">​</a></h3>
<p><img decoding="async" loading="lazy" alt="FF Announcement" src="/assets/images/img2-846063bd092bc571aad305ae7253a190.jpg" width="3484" height="1146" class="img_ev3q">
Real-time updates and Changelog are very important features required by streaming analytics and Flink.
At its core, Fluss streaming storage is built on a Log Tablet, with a key-value (KV) index constructed over the Log.
The relationship between the Log and KV mirrors the concept of stream-table duality:
updates to the KV generate a changelog that is written to the Log. In the event of a failure, data from the Log is used to recover the KV.</p>
<p>The KV index is implemented as a Log-Structured Merge (LSM) tree to support large-scale real-time updates,
and also support partial-update which can be used to build wide tables very efficiently. In addition, the changelog
generated by KV can be read directly by Flink without additional deduplication cost, which saves a lot of computing resources.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="queryable">Queryable<a href="#queryable" class="hash-link" aria-label="Direct link to Queryable" title="Direct link to Queryable">​</a></h3>
<p><img decoding="async" loading="lazy" alt="FF Announcement" src="/assets/images/img3-f76df2882b217d4aa58efba2edae07d8.jpg" width="3468" height="1148" class="img_ev3q">
The built-in KV indexes enable high-performance primary key lookups, making Fluss suitable for real-time processing tasks such as dimension table joins. Users can also perform direct data exploration with Fluss, including queries with operations like LIMIT and COUNT, to make debugging data in Fluss very easy.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="unification-of-stream-and-lakehouse">Unification of Stream and Lakehouse<a href="#unification-of-stream-and-lakehouse" class="hash-link" aria-label="Direct link to Unification of Stream and Lakehouse" title="Direct link to Unification of Stream and Lakehouse">​</a></h3>
<p><img decoding="async" loading="lazy" alt="FF Announcement" src="/assets/images/img4-80846362d40e3239bfcd92216276b72d.jpg" width="3698" height="1218" class="img_ev3q">
One of Fluss&#x27;s standout features is the unification of stream and Lakehouse. In traditional Lambda architecture, you have to duplicate data in both real-time layer and batch layer. While Fluss eliminates this redundancy by unifying &quot;data stored in stream&quot; and &quot;data stored in lake&quot;. This unification ensures consistent data and metadata while reducing storage costs and simplifying data workflows.</p>
<p>At its core, Fluss incorporates a <code>compaction service</code> that ensures seamless integration between stream and lake storage. This service automatically and continuously converts Fluss data into the data lake format.
A key feature here is called &quot;Shared Data&quot;. The Lakehouse storage serves as the historical data layer for the streaming storage, which is optimized for storing long-term data with minute-level latencies. On the other hand, streaming storage serves as the real-time data layer for Lakehouse storage, which is optimized for storing short-term data with millisecond-level latencies.
The data is shared with each other, and is exposed as a single table.
For streaming queries on the table, it firstly uses the Lakehouse storage as historical data to have efficient catch-up read performance, and then seamlessly transitions to the streaming storage for real-time data, ensuring no duplicate data is read.
For batch queries on the table, streaming storage supplements real-time data for Lakehouse storage, enabling second-level freshness for Lakehouse analytics.
This capability, termed <strong>Union Read</strong>, allows both layers to work in tandem for highly efficient and accurate data access.</p>
<p>In addition, the automatically converted data lake tables fully adhere to open table format protocols, ensuring compatibility with existing query engines such as Apache Spark, StarRocks, and Trino.
These engines can directly query data on Lakehouse storage, seamlessly integrating it into users&#x27; existing Lakehouse architectures.</p>
<p>Fluss has already completed integration with Apache Paimon, and integration with Apache Iceberg is underway. This commitment to compatibility ensures that Fluss remains a flexible and powerful component in the modern data stack, bridging real-time and historical data for unified analytics and storage efficiency.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="overall-architecture">Overall Architecture<a href="#overall-architecture" class="hash-link" aria-label="Direct link to Overall Architecture" title="Direct link to Overall Architecture">​</a></h2>
<p><img decoding="async" loading="lazy" alt="FF Announcement" src="/assets/images/img9-fb689d41f612ef840508c4c20399822c.jpg" width="3686" height="1242" class="img_ev3q">
This is the overall architecture of Fluss, a cutting-edge streaming storage solution designed specifically for real-time analytics. Fluss operates a server cluster to provide high-performance real-time read and write capabilities, while leveraging remote storage for data tiering to optimize storage costs. Additionally, Fluss integrates seamlessly with Lakehouse architectures, enabling robust query capabilities and a unified data ecosystem.</p>
<p>The core features of Fluss include real-time streaming reads and writes, column pruning, streaming updates, changelog subscription, real-time lookup queries, and integration of stream and Lakehouse.</p>
<p>With its robust architecture and comprehensive feature set, Fluss empowers organizations to bridge the gap between real-time and historical data, enabling efficient, scalable, and cost-effective solutions for real-time analytics.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="use-case-delta-join">Use Case: Delta Join<a href="#use-case-delta-join" class="hash-link" aria-label="Direct link to Use Case: Delta Join" title="Direct link to Use Case: Delta Join">​</a></h2>
<p><img decoding="async" loading="lazy" alt="FF Announcement" src="/assets/images/img5-c1bedf1a8c60844ffd67f77f722157f9.jpg" width="3650" height="1222" class="img_ev3q">
The combination of Fluss’s key features lends itself to a highly effective use case: Delta Join. Apache Flink provides a foundational feature called Stream-Stream Join, widely used for building wide tables. However, it is often one of the most challenging operations in Flink.
Stream-stream joins require maintaining the full upstream data in the state, leading to significant resource consumption. For instance, one of Taobao&#x27;s largest Flink jobs is a stream-stream join (exposing associated orders), which needs to maintains a state of over 50 TB. This brings many challenges, such as high cost, unstable job, checkpoint timeout, slow restart recovery, etc.</p>
<p>To address these challenges, we developed a new Flink join operator implementation called Delta Join, leveraging Fluss’s streaming read and secondary-index lookup capabilities. Delta Join operates like a &quot;bilateral driven lookup join&quot;, that is:
when data arrives from the left stream, the right table is queried using the join key;
when data arrives from the right stream, the left table is queried using the join key.
This approach eliminates state like Lookup Join, while preserving the semantics of a Stream-Stream Join (any updates on either side triggers an update to the join result).</p>
<p>We tested Taobao&#x27;s largest stream-stream join job and migrated to delta join. The results were impressive:</p>
<ul>
<li><strong>Eliminate State:</strong> Migrating from stream-stream join to delta join eliminated the need for <code>50 TB</code> join state, leading to enhanced job stability and avoid checkpoint timeouts.</li>
<li><strong>Resource Optimization:</strong> Flink resource cost decreased by 10x, dropping from <code>2300 CU</code> to <code>200 CU</code>, while maintaining the same throughput.</li>
<li><strong>Faster Backfilling:</strong> By leveraging Fluss’s Lakehouse integration, we can use the converted Paimon/Iceberg table and Sort-Merge Join in batch mode for data backfilling. Re-processing one day data was reduced from <code>4 hours</code> to <code>30 minutes</code>.</li>
</ul>
<p>Besides the numbers, Delta Join&#x27;s most significant benefit lies in its user flexibility.
Unlike traditional stream-stream joins, where the state is tightly coupled with Flink job, operating as an opaque &#x27;black box&#x27;, any job modification requires a costly and time-consuming state rebuild.
Delta Join addresses this by decoupling the state from the job, facilitating effortless job modifications without the need to reconstruct the state.
This separation not only boosts backfilling efficiency but also makes state data easily accessible in Fluss for analysis, thereby enhancing business agility and increasing developer productivity.</p>
<p>To formalize this innovation, we submitted the Delta Join <a href="https://cwiki.apache.org/confluence/display/FLINK/FLIP-486%3A+Introduce+A+New+DeltaJoin" target="_blank" rel="noopener noreferrer">FLIP-486 proposal</a> to the Apache Flink community. We invite those interested to review and contribute to this exciting advancement.</p>
<p>Delta Join, powered by Fluss, represents a breakthrough in real-time analytics by significantly reducing resource consumption, enhancing performance, and unlocking flexibility in stateful stream processing.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="future-plan">Future Plan<a href="#future-plan" class="hash-link" aria-label="Direct link to Future Plan" title="Direct link to Future Plan">​</a></h2>
<p><img decoding="async" loading="lazy" alt="FF Announcement" src="/assets/images/img6-3e455650eb36e97091211441c91b48ac.jpg" width="3700" height="1116" class="img_ev3q">
The future planning for Fluss involves three key aspects, each corresponding to its relationship with three open-source software projects:</p>
<ul>
<li><strong>Apache Kafka Protocol Compatibility:</strong> This is aimed at helping existing streaming data migrate to Fluss more effectively.</li>
<li><strong>Storage for Apache Flink:</strong> Fluss aims to be the best storage for Apache Flink and streaming analytics, offering deep optimization with Flink across the storage, optimizer and execution layer. Delta Join marks our first major step, with many more exciting features on the way.</li>
<li><strong>Real-Time Data Layer for Apache Iceberg:</strong> By unifying stream and Lakehouse, Fluss is committed to providing a robust real-time data layer for Apache Iceberg and Apache Paimon. This vision includes creating a unified storage solution that supports both real-time and offline analytics.</li>
</ul>
<p>There are more exciting work happening in the community. You can check out <a href="/roadmap/">Fluss Roadmap</a> for a comprehensive future planning.</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/unified-streaming-lakehouse/"><div class="pagination-nav__sublabel">Newer post</div><div class="pagination-nav__label">Towards A Unified Streaming &amp; Lakehouse Architecture</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/why-fluss/"><div class="pagination-nav__sublabel">Older post</div><div class="pagination-nav__label">Why Fluss? Top 4 Challenges of Using Kafka for Real-Time Analytics</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#key-features-of-fluss" class="table-of-contents__link toc-highlight">Key Features of Fluss</a><ul><li><a href="#columnar-stream" class="table-of-contents__link toc-highlight">Columnar Stream</a></li><li><a href="#real-time-updates-and-changelog" class="table-of-contents__link toc-highlight">Real-Time Updates and Changelog</a></li><li><a href="#queryable" class="table-of-contents__link toc-highlight">Queryable</a></li><li><a href="#unification-of-stream-and-lakehouse" class="table-of-contents__link toc-highlight">Unification of Stream and Lakehouse</a></li></ul></li><li><a href="#overall-architecture" class="table-of-contents__link toc-highlight">Overall Architecture</a></li><li><a href="#use-case-delta-join" class="table-of-contents__link toc-highlight">Use Case: Delta Join</a></li><li><a href="#future-plan" class="table-of-contents__link toc-highlight">Future Plan</a></li></ul></div></div></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 The Apache Software Foundation.
      Apache®, Apache Flink®, Flink®, Apache Kafka®, Kafka®, Spark® and associated open source project names and logos are trademarks of the Apache Software Foundation.</div></div></div></footer></div>
</body>
</html>